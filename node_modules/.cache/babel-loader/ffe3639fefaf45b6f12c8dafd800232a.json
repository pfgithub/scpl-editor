{"ast":null,"code":"\"use strict\"; // ========≠==========\n// This file is a mess\n// Enter at your own risk\n// ========≠==========\n\nvar _toConsumableArray = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _get = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/get\");\n\nvar _possibleConstructorReturn = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _classCallCheck = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar uuidv4 = require(\"uuid/v4\");\n/*\nCoercionItemClass?: AggrandizementCoercionItemClass;\nDictionaryKey?: string;\nPropertyName?: AggrandizementPropertyName;\nPropertyUserInfo?: AggrandizementPropertyUserInfo;\nType: AggrandizementType;\nWFDateFormat?: string;\nWFDateFormatStyle?: WFDateFormatStyle;\nWFTimeFormatStyle?: WFTimeFormatStyle;\nWFISO8601IncludeTime?: boolean;\nWFRelativeDateFormatStyle?: WFRelativeDateFormatStyle;\n\nFrom Shortcuts-js\n */\n\n\nvar Types_1 = require(\"./WFTypes/Types\");\n\nvar GetTypes_1 = require(\"./Data/GetTypes\");\n\nvar ShortcutMeta_1 = require(\"./Data/ShortcutMeta\");\n\nvar coercionTypes = {\n  // remove name:string and make it typed too\n  anything: \"WFContentItem\",\n  appstoreapp: \"WFAppStoreAppContentItem\",\n  article: \"WFArticleContentItem\",\n  boolean: \"WFBooleanContentItem\",\n  contact: \"WFContactContentItem\",\n  date: \"WFDateContentItem\",\n  dictionary: \"WFDictionaryContentItem\",\n  emailaddress: \"WFEmailAddressContentItem\",\n  file: \"WFGenericFileContentItem\",\n  image: \"WFImageContentItem\",\n  itunesmedia: \"WFMPMediaContentItem\",\n  itunesproduct: \"WFiTunesProductContentItem\",\n  location: \"WFLocationContentItem\",\n  mapslink: \"WFDCMapsLinkContentItem\",\n  media: \"WFAVAssetContentItem\",\n  number: \"WFNumberContentItem\",\n  pdf: \"WFPDFContentItem\",\n  phonenumber: \"WFPhoneNumberContentItem\",\n  photomedia: \"WFPhotoMediaContentItem\",\n  place: \"WFMKMapItemContentItem\",\n  richtext: \"WFRichTextContentItem\",\n  safariwebpage: \"WFSafariWebPageContentItem\",\n  text: \"WFStringContentItem\",\n  url: \"WFURLContentItem\",\n  vcard: \"WFVCardContentItem\"\n};\nexports.inverseCoercionTypes = {\n  WFContentItem: \"anything\",\n  WFAppStoreAppContentItem: \"appstoreapp\",\n  WFArticleContentItem: \"article\",\n  WFBooleanContentItem: \"boolean\",\n  WFContactContentItem: \"contact\",\n  WFDateContentItem: \"date\",\n  WFTimeLengthContentItem: \"timelength\",\n  WFTimeContentItem: \"time\",\n  WFDictionaryContentItem: \"dictionary\",\n  WFEmailAddressContentItem: \"emailaddress\",\n  WFGenericFileContentItem: \"file\",\n  WFImageContentItem: \"image\",\n  WFMPMediaContentItem: \"itunesmedia\",\n  WFiTunesProductContentItem: \"itunesproduct\",\n  WFLocationContentItem: \"location\",\n  WFDCMapsLinkContentItem: \"mapslink\",\n  WFAVAssetContentItem: \"media\",\n  WFNumberContentItem: \"number\",\n  WFPDFContentItem: \"pdf\",\n  WFPhoneNumberContentItem: \"phonenumber\",\n  WFPhotoMediaContentItem: \"photomedia\",\n  WFMKMapItemContentItem: \"place\",\n  WFRichTextContentItem: \"richtext\",\n  WFSafariWebPageContentItem: \"safariwebpage\",\n  WFStringContentItem: \"text\",\n  WFURLContentItem: \"url\",\n  WFVCardContentItem: \"vcard\",\n  WFEnumerationContentItem: \"enumeration\"\n};\n\nvar Aggrandizements =\n/*#__PURE__*/\nfunction () {\n  function Aggrandizements() {\n    _classCallCheck(this, Aggrandizements);\n\n    this.coercionType = undefined;\n    this.getProperty = undefined;\n    this.getForKey = undefined;\n  }\n\n  _createClass(Aggrandizements, [{\n    key: \"build\",\n    value: function build() {\n      var aggrandizements = [];\n\n      if (this.coercionType) {\n        aggrandizements.push({\n          CoercionItemClass: this.coercionType,\n          Type: \"WFCoercionVariableAggrandizement\"\n        });\n      }\n\n      if (this.getProperty) {\n        aggrandizements.push(Object.assign({\n          PropertyName: this.getProperty.name\n        }, this.getProperty.data ? {\n          PropertyUserInfo: this.getProperty.data\n        } : {}, {\n          Type: \"WFPropertyVariableAggrandizement\"\n        }));\n      }\n\n      if (this.getForKey) {\n        aggrandizements.push({\n          DictionaryKey: this.getForKey,\n          Type: \"WFDictionaryValueVariableAggrandizement\"\n        });\n      }\n\n      return aggrandizements;\n    }\n  }, {\n    key: \"setProperty\",\n    value: function setProperty(getType) {\n      // if !this.coercionType throw error(to get a property must have coercion type. fix this by adding as:)\n      getType = getType.toLowerCase().replace(/[^A-Za-z]/g, \"\");\n\n      if (!this.coercionType) {\n        return \"To get a property of a variable, you must have a coercion type set. Fix this by adding `as:` to your aggrandizements dictionary.\";\n      }\n\n      if (!Types_1.isAggrandizementPropertyName(getType)) {\n        return \"\".concat(getType, \" is not a valid aggrandizement get type. Valid are: \").concat(Object.keys(GetTypes_1.default[this.coercionType]), \".\");\n      }\n\n      var typeValue = GetTypes_1.default[this.coercionType].properties[getType];\n\n      if (!typeValue) {\n        return \"\".concat(getType, \" is not a valid aggrandizement get type for this as. Valid are: \").concat(Object.keys(GetTypes_1.default[this.coercionType]), \".\");\n      }\n\n      this.getProperty = typeValue;\n    }\n  }, {\n    key: \"setCoercionType\",\n    value: function setCoercionType(type) {\n      // if gettype, error\n      // if !coercion type exists throw error(coercion type does not exist)\n      type = type.toLowerCase().split(\" \").join(\"\");\n      var coercionClass = coercionTypes[type];\n\n      if (!coercionClass) {\n        return \"`\".concat(type, \"` is not a valid as type. Valid are: \").concat(Object.keys(coercionTypes).join(\", \"));\n      }\n\n      if (this.getProperty || this.getForKey) {\n        return \"Cannot change as type when get property/get for key is already set.\";\n      }\n\n      this.coercionType = coercionClass;\n    }\n  }, {\n    key: \"setForKey\",\n    value: function setForKey(key) {\n      // if !coercion type === dictionary throw error(coercion type must be dictionary)\n      if (this.coercionType !== \"WFDictionaryContentItem\") {\n        return \"As type must be dictionary to use key. Fix this by adding as:Dictionary.\";\n      }\n\n      this.getForKey = key;\n    }\n  }], [{\n    key: \"inverse\",\n    value: function inverse(data) {\n      var res = new Aggrandizements();\n      data.forEach(function (aggrandizement) {\n        if (aggrandizement.Type === \"WFCoercionVariableAggrandizement\") {\n          res.coercionType = aggrandizement.CoercionItemClass;\n          return;\n        }\n\n        if (aggrandizement.Type === \"WFPropertyVariableAggrandizement\") {\n          res.getProperty = {\n            name: aggrandizement.PropertyName,\n            data: aggrandizement.PropertyUserInfo\n          };\n          return;\n        }\n\n        if (aggrandizement.Type === \"WFDictionaryValueVariableAggrandizement\") {\n          res.getForKey = aggrandizement.DictionaryKey;\n          return;\n        }\n      });\n      return res;\n    }\n  }]);\n\n  return Aggrandizements;\n}();\n\nexports.Aggrandizements = Aggrandizements; // // // // // //\n//  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //\n\nvar Parameter =\n/*#__PURE__*/\nfunction () {\n  // cannot be abstract because inverse is static\n  function Parameter() {\n    _classCallCheck(this, Parameter);\n  }\n\n  _createClass(Parameter, [{\n    key: \"build\",\n    value: function build() {\n      throw new Error(\"Blank parameter has no build method\");\n    }\n  }]);\n\n  return Parameter;\n}();\n\nvar ContentItemFilter =\n/*#__PURE__*/\nfunction (_Parameter) {\n  _inherits(ContentItemFilter, _Parameter);\n\n  function ContentItemFilter(coercionType, mode) {\n    var _this;\n\n    _classCallCheck(this, ContentItemFilter);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ContentItemFilter).call(this));\n    _this.data = [];\n    _this.coercionType = coercionType;\n    _this.mode = mode;\n    return _this;\n  }\n\n  _createClass(ContentItemFilter, [{\n    key: \"getTypeInfo\",\n    value: function getTypeInfo(item) {\n      var property = item.property;\n      var operator = item.operator; // const units = item.units;\n\n      var typeInfo = GetTypes_1.default[this.coercionType]; // property -> GetTypeInfo -> AggrandizementPropertyRawName\n\n      if (!Types_1.isAggrandizementPropertyName(property)) {\n        return {\n          error: true,\n          message: \"Not a valid name `\".concat(property, \"`. Check the docs page for this action for a full list.\")\n        };\n      }\n\n      var propertyData = typeInfo.properties[property];\n\n      if (!propertyData) {\n        return {\n          error: true,\n          message: \"Not a valid property name `\".concat(property, \"`. Check the docs page for this action for a full list.\")\n        };\n      }\n\n      if (propertyData.filter === undefined) {\n        return {\n          error: true,\n          message: \"The property `\".concat(property, \"` does not yet support filters on this action. If you need this property, report an issue on github or submit a pull request.\")\n        };\n      }\n\n      if (!propertyData.filter) {\n        return {\n          error: true,\n          message: \"The property `\".concat(property, \"` does not support filters in shortcuts. Check the docs page for this action for a full list.\")\n        };\n      } // ComparisonName -> ComparisonValue\n\n\n      var operatorValue = GetTypes_1.comparisonMethodsMap.get(operator);\n\n      if (operatorValue === undefined) {\n        return {\n          error: true,\n          message: \"The operator `\".concat(operator, \"` does not exist or has not been implemented. Check the docs page for this action for a full list.\")\n        };\n      } // UnitName -> UnitValue || 4\n      // const unit = units;\n\n\n      var expectedType;\n\n      if (propertyData.type === \"WFEnumerationContentItem\") {\n        expectedType = \"string\";\n      } else if (propertyData.type === \"WFStringContentItem\") {\n        expectedType = \"stringOrText\";\n      } else if (propertyData.type === \"WFNumberContentItem\") {\n        expectedType = \"number\";\n      } else if (propertyData.type === \"WFBooleanContentItem\") {\n        expectedType = \"boolean\";\n      }\n\n      if (!expectedType) {\n        return {\n          error: true,\n          message: \"The type `\".concat(propertyData.type, \"` is probably not implemented yet.\")\n        };\n      }\n\n      return {\n        error: false,\n        expectedType: expectedType,\n        typeData: {\n          propertyData: propertyData,\n          operatorValue: operatorValue\n        }\n      };\n    }\n  }, {\n    key: \"add\",\n    value: function add(value, typeData) {\n      var propertyData = typeData.propertyData,\n          operatorValue = typeData.operatorValue;\n      var baseData = {\n        Property: propertyData.name,\n        Operator: operatorValue,\n        Removable: true,\n        Unit: 4,\n        VariableOverrides: {}\n      };\n\n      if (propertyData.type === \"WFEnumerationContentItem\") {\n        if (typeof value !== \"string\") {\n          return \"Enums must have strings.\";\n        }\n\n        var enumoptions = propertyData.filterEnumValues;\n\n        if (!enumoptions) {\n          return \"This enum was set up wrong. \".concat(propertyData.name, \". Report an issue.\");\n        }\n\n        if (enumoptions.indexOf(value) > -1) {\n          this.data.push(Object.assign({\n            Enumeration: value\n          }, baseData));\n          return;\n        }\n\n        return \"Must be one of \".concat(enumoptions.join(\",\"));\n      } else if (propertyData.type === \"WFStringContentItem\") {\n        if (value instanceof Text) {\n          var built = value.build();\n\n          if (typeof built === \"string\") {\n            this.data.push(Object.assign({\n              String: built\n            }, baseData));\n            return;\n          }\n\n          this.data.push(Object.assign({}, baseData, {\n            VariableOverrides: {\n              stringValue: value.build()\n            }\n          }));\n          return;\n        }\n\n        if (typeof value !== \"string\") {\n          return \"Strings must have strings.\";\n        }\n\n        this.data.push(Object.assign({\n          String: value\n        }, baseData));\n        return;\n      } else if (propertyData.type === \"WFNumberContentItem\") {\n        if (typeof value !== \"number\") {\n          return \"Numbers must have strings.\";\n        }\n\n        this.data.push(Object.assign({\n          Number: value\n        }, baseData));\n        return;\n      } else if (propertyData.type === \"WFBooleanContentItem\") {\n        if (typeof value !== \"boolean\") {\n          return \"Booleans must have booleans.\";\n        }\n\n        this.data.push(Object.assign({\n          Bool: value\n        }, baseData));\n        return;\n      } // Add to data\n\n\n      return \"Something's not right. This is none of string|number|boolean|Text.\";\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      return {\n        Value: {\n          WFActionParameterFilterPrefix: this.mode === \"and\" ? 1 : 0,\n          WFContentPredicateBoundedDate: false,\n          WFActionParameterFilterTemplates: this.data\n        },\n        WFSerializationType: \"WFContentPredicateTableTemplate\"\n      };\n    }\n  }], [{\n    key: \"inverse\",\n    value: function inverse(data, coercionTypeClass) {\n      var filter = new ContentItemFilter(coercionTypeClass, data.Value.WFActionParameterFilterPrefix ? \"and\" : \"or\");\n      data.Value.WFActionParameterFilterTemplates.forEach(function (template) {\n        filter.data.push(template);\n      });\n      return filter;\n    }\n  }]);\n\n  return ContentItemFilter;\n}(Parameter);\n\nexports.ContentItemFilter = ContentItemFilter; // export class ContentItemFilterItem extends Parameter {\n// \tproperty: string;\n// \toperator: ComparisonName;\n// \tvalue: string;\n// \tunits?: number;\n// \tconstructor(\n// \t\tproperty: propertyNameMap,\n// \t\toperator: ComparisonName,\n// \t\tvalue: string,\n// \t\tunits?: undefined\n// \t) {\n// \t\tsuper();\n// \t\tthis.property = property;\n// \t\tthis.operator = operator;\n// \t\tthis.value = value;\n// \t\tthis.units = units;\n// \t}\n// \tbuild(): WFContentItemFilterItem {} // build(for: ContentItemFilter)\n// }\n\nvar Dictionary =\n/*#__PURE__*/\nfunction (_Parameter2) {\n  _inherits(Dictionary, _Parameter2);\n\n  function Dictionary() {\n    var _this2;\n\n    _classCallCheck(this, Dictionary);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Dictionary).call(this));\n    _this2.items = [];\n    return _this2;\n  }\n\n  _createClass(Dictionary, [{\n    key: \"add\",\n    value: function add(key, value) {\n      this.items.push({\n        key: key,\n        value: value\n      });\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      return {\n        Value: {\n          WFDictionaryFieldValueItems: this.items.map(function (_ref) {\n            var key = _ref.key,\n                value = _ref.value;\n\n            if (value instanceof Dictionary) {\n              // For unknown reasons, an extra serializationtype is needed on dictionaries\n              return {\n                WFItemType: 1,\n                WFKey: key.build(),\n                WFValue: {\n                  Value: value.build(),\n                  WFSerializationType: \"WFDictionaryFieldValue\"\n                }\n              };\n            }\n\n            if (value instanceof List) {\n              // For unknown reasons, an extra serializationtype is needed on lists\n              return {\n                WFItemType: 2,\n                WFKey: key.build(),\n                WFValue: {\n                  Value: value.build(),\n                  WFSerializationType: \"WFArrayParameterState\"\n                }\n              };\n            } // For unknown reasons, an extra serializationtype is not needed on text\n\n\n            if (value instanceof Text) {\n              return {\n                WFItemType: 0,\n                WFKey: key.build(),\n                WFValue: value.build()\n              };\n            }\n\n            if (typeof value === \"boolean\") {\n              return {\n                WFItemType: 4,\n                WFKey: key.build(),\n                WFValue: {\n                  Value: value ? 1 : false,\n                  WFSerializationType: \"WFNumberSubstitutableState\"\n                }\n              };\n            }\n\n            if (typeof value === \"number\") {\n              return {\n                WFItemType: 3,\n                WFKey: key.build(),\n                WFValue: new Text().add(\"\".concat(value)).build()\n              };\n            }\n\n            if (value instanceof Attachment) {\n              return {\n                WFItemType: 5,\n                WFKey: key.build(),\n                WFValue: {\n                  Value: value.build(),\n                  WFSerializationType: \"WFTokenAttachmentParameterState\"\n                }\n              };\n            }\n\n            return {\n              WFItemType: 0,\n              WFKey: key.build(),\n              WFValue: \"??an error occured??\"\n            };\n          })\n        },\n        WFSerializationType: \"WFDictionaryFieldValue\"\n      };\n    }\n  }], [{\n    key: \"inverse\",\n    value: function inverse(data) {\n      var res = new Dictionary();\n      data.Value.WFDictionaryFieldValueItems.forEach(function (item) {\n        if (item.WFItemType === 1) {\n          return res.add(Text.inverse(item.WFKey), Dictionary.inverse(item.WFValue.Value));\n        }\n\n        if (item.WFItemType === 2) {\n          return res.add(Text.inverse(item.WFKey), List.inverse(item.WFValue.Value));\n        }\n\n        if (item.WFItemType === 0) {\n          return res.add(Text.inverse(item.WFKey), Text.inverse(item.WFValue));\n        }\n\n        if (item.WFItemType === 3) {\n          return res.add(Text.inverse(item.WFKey), Text.inverse(item.WFValue));\n        }\n\n        if (item.WFItemType === 4) {\n          return res.add(Text.inverse(item.WFKey), !!item.WFValue.Value);\n        }\n\n        if (item.WFItemType === 5) {\n          return res.add(Text.inverse(item.WFKey), Attachment.inverse(item.WFValue.Value));\n        }\n\n        return res.add(Text.inverse(item.WFKey), new ErrorParameter());\n      });\n      return res;\n    }\n  }]);\n\n  return Dictionary;\n}(Parameter);\n\nexports.Dictionary = Dictionary;\n\nvar Attachment =\n/*#__PURE__*/\nfunction (_Parameter3) {\n  _inherits(Attachment, _Parameter3);\n\n  function Attachment(type) {\n    var _this3;\n\n    _classCallCheck(this, Attachment);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Attachment).call(this));\n    _this3.type = type;\n    _this3.aggrandizements = new Aggrandizements();\n    return _this3;\n  }\n\n  _createClass(Attachment, [{\n    key: \"build\",\n    value: function build() {\n      return {\n        Value: {\n          Type: this.type,\n          Aggrandizements: this.aggrandizements.build()\n        },\n        WFSerializationType: \"WFTextTokenAttachment\"\n      };\n    }\n  }], [{\n    key: \"inverse\",\n    value: function inverse(value) {\n      var result;\n\n      if (value.Value.Type === \"Variable\") {\n        result = NamedVariable.inverse(value);\n      } else if (value.Value.Type === \"ActionOutput\") {\n        result = MagicVariable.inverse(value);\n      } else {\n        result = new Attachment(value.Value.Type);\n      }\n\n      if (value.Value.Aggrandizements) {\n        result.aggrandizements = Aggrandizements.inverse(value.Value.Aggrandizements);\n      }\n\n      return result;\n    }\n  }]);\n\n  return Attachment;\n}(Parameter);\n\nexports.Attachment = Attachment;\n\nvar Variable =\n/*#__PURE__*/\nfunction (_Attachment) {\n  _inherits(Variable, _Attachment);\n\n  function Variable(type) {\n    _classCallCheck(this, Variable);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Variable).call(this, type));\n  }\n\n  _createClass(Variable, [{\n    key: \"build\",\n    value: function build() {\n      var sb = _get(_getPrototypeOf(Variable.prototype), \"build\", this).call(this);\n\n      return sb;\n    }\n  }]);\n\n  return Variable;\n}(Attachment);\n\nexports.Variable = Variable;\n\nvar NamedVariable =\n/*#__PURE__*/\nfunction (_Variable) {\n  _inherits(NamedVariable, _Variable);\n\n  function NamedVariable(varname) {\n    var _this4;\n\n    _classCallCheck(this, NamedVariable);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(NamedVariable).call(this, \"Variable\"));\n    _this4.varname = varname;\n    return _this4;\n  }\n\n  _createClass(NamedVariable, [{\n    key: \"build\",\n    value: function build() {\n      return {\n        Value: {\n          Type: \"Variable\",\n          Aggrandizements: this.aggrandizements.build(),\n          VariableName: this.varname\n        },\n        WFSerializationType: \"WFTextTokenAttachment\"\n      };\n    }\n  }], [{\n    key: \"inverse\",\n    value: function inverse(data) {\n      return new NamedVariable(data.Value.VariableName);\n    }\n  }]);\n\n  return NamedVariable;\n}(Variable);\n\nexports.NamedVariable = NamedVariable;\n\nvar MagicVariable =\n/*#__PURE__*/\nfunction (_Variable2) {\n  _inherits(MagicVariable, _Variable2);\n\n  function MagicVariable() {\n    var _this5;\n\n    _classCallCheck(this, MagicVariable);\n\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(MagicVariable).call(this, \"ActionOutput\"));\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (args[0] instanceof Action) {\n      _this5.varname = args[0].magicvarname || args[0].name || \"??unnamed??\";\n      _this5.uuid = args[0].uuid;\n    } else if (typeof args[1] === \"string\") {\n      _this5.varname = args[0];\n      _this5.uuid = args[1];\n    } else {\n      throw new Error(\"This is not possible.\");\n    }\n\n    return _this5;\n  }\n\n  _createClass(MagicVariable, [{\n    key: \"build\",\n    value: function build() {\n      return {\n        Value: {\n          Type: \"ActionOutput\",\n          Aggrandizements: this.aggrandizements.build(),\n          OutputName: this.varname,\n          OutputUUID: this.uuid\n        },\n        WFSerializationType: \"WFTextTokenAttachment\"\n      };\n    }\n  }], [{\n    key: \"inverse\",\n    value: function inverse(data) {\n      return new MagicVariable(data.Value.OutputName, data.Value.OutputUUID);\n    }\n  }]);\n\n  return MagicVariable;\n}(Variable);\n\nexports.MagicVariable = MagicVariable;\nexports.WFTimeOffsetValueUnitList = [[\"Second\", \"Seconds\"], [\"Minute\", \"Minutes\"], [\"Hour\", \"Hours\"], [\"Day\", \"Days\"], [\"Week\", \"Weeks\"], [\"Month\", \"Months\"], [\"Year\", \"Years\"]];\nexports.WFTimeOffsetValueEnumList = [\"Get Start Of Minute\", \"Get Start Of Hour\", \"Get Start Of Day\", \"Get Start Of Week\", \"Get Start Of Month\", \"Get Start Of Year\"];\n\nvar AdjustOffset =\n/*#__PURE__*/\nfunction (_Parameter4) {\n  _inherits(AdjustOffset, _Parameter4);\n\n  function AdjustOffset(opts) {\n    var _this6;\n\n    _classCallCheck(this, AdjustOffset);\n\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(AdjustOffset).call(this));\n    _this6.opts = opts;\n    return _this6;\n  }\n\n  _createClass(AdjustOffset, [{\n    key: \"build\",\n    value: function build() {\n      return {\n        Value: this.opts.v === \"onearg\" ? {\n          Unit: \"Second\",\n          Value: 0,\n          Operation: this.opts.mode\n        } : {\n          Unit: this.opts.unit,\n          Value: this.opts.value instanceof Attachment ? this.opts.value.build().Value : this.opts.value,\n          Operation: this.opts.mode\n        },\n        WFSerializationType: \"WFTimeOffsetValue\"\n      };\n    }\n  }], [{\n    key: \"inverse\",\n    value: function inverse(data) {\n      if (exports.WFTimeOffsetValueEnumList.indexOf(data.Value.Operation) > -1) {\n        return new AdjustOffset({\n          v: \"onearg\",\n          mode: data.Value.Operation\n        });\n      }\n\n      var operation = data.Value.Operation;\n      return new AdjustOffset({\n        v: \"threearg\",\n        mode: operation,\n        unit: data.Value.Unit,\n        value: typeof data.Value.Value === \"number\" ? data.Value.Value : Attachment.inverse({\n          Value: data.Value.Value,\n          WFSerializationType: \"WFTextTokenAttachment\"\n        })\n      });\n    }\n  }]);\n\n  return AdjustOffset;\n}(Parameter);\n\nexports.AdjustOffset = AdjustOffset;\n\nvar List =\n/*#__PURE__*/\nfunction (_Parameter5) {\n  _inherits(List, _Parameter5);\n\n  function List(list) {\n    var _this7;\n\n    _classCallCheck(this, List);\n\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(List).call(this));\n    _this7._list = list;\n    return _this7;\n  }\n\n  _createClass(List, [{\n    key: \"add\",\n    value: function add(item) {\n      this._list.push(item);\n    }\n  }, {\n    key: \"getItems\",\n    value: function getItems() {\n      return this._list;\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      return this._list.map(function (i) {\n        if (typeof i === \"string\") {\n          return i;\n        }\n\n        if (i instanceof Text) {\n          var text = i.build();\n\n          if (typeof text === \"string\") {\n            return text;\n          }\n\n          return {\n            WFItemType: 0,\n            WFValue: text\n          };\n        }\n\n        if (i instanceof Dictionary) {\n          var dictionary = i.build();\n          return {\n            WFItemType: 1,\n            WFValue: dictionary\n          };\n        }\n\n        if (i instanceof List) {\n          var list = i.build();\n          return {\n            WFItemType: 2,\n            WFValue: list\n          };\n        }\n\n        if (typeof i === \"boolean\") {\n          return {\n            WFItemType: 4,\n            WFValue: {\n              Value: i ? 1 : false,\n              WFSerializationType: \"WFNumberSubstitutableState\"\n            }\n          };\n        }\n\n        return \"??error item??\";\n      });\n    }\n  }], [{\n    key: \"inverse\",\n    value: function inverse(data) {\n      var reslist = new List([]);\n      data.forEach(function (item) {\n        if (typeof item === \"string\") {\n          return reslist.add(item);\n        }\n\n        if (item.WFItemType === 0) {\n          return reslist.add(Text.inverse(item.WFValue));\n        }\n\n        if (item.WFItemType === 1) {\n          return reslist.add(Dictionary.inverse(item.WFValue));\n        }\n\n        if (item.WFItemType === 2) {\n          return reslist.add(List.inverse(item.WFValue));\n        }\n\n        if (item.WFItemType === 3) {\n          return reslist.add(Text.inverse(item.WFValue));\n        }\n\n        if (item.WFItemType === 4) {\n          return reslist.add(!!item.WFValue.Value);\n        }\n      });\n      return reslist;\n    }\n  }]);\n\n  return List;\n}(Parameter);\n\nexports.List = List;\n\nvar Text =\n/*#__PURE__*/\nfunction (_Parameter6) {\n  _inherits(Text, _Parameter6);\n\n  function Text() {\n    var _this8;\n\n    _classCallCheck(this, Text);\n\n    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(Text).call(this));\n    _this8._components = [];\n    return _this8;\n  }\n\n  _createClass(Text, [{\n    key: \"components\",\n    value: function components() {\n      return this._components;\n    }\n  }, {\n    key: \"add\",\n    value: function add() {\n      var _this9 = this;\n\n      for (var _len2 = arguments.length, objs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        objs[_key2] = arguments[_key2];\n      }\n\n      objs.forEach(function (obj) {\n        if (obj instanceof Attachment) {\n          _this9._components.push(obj);\n\n          return;\n        }\n\n        if (obj instanceof Text) {\n          _this9.add.apply(_this9, _toConsumableArray(obj._components));\n\n          return;\n        }\n\n        if (!(typeof obj === \"string\")) {\n          throw new Error(\"Add type must be string, Text, or Attachment\");\n        }\n\n        if (obj.length === 0) {\n          return;\n        } // nothing to add\n\n\n        var str = obj;\n\n        _this9._components.push(str);\n      });\n      return this;\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      // if(this.components.length === 0) {return \"\";}\n      // if(this.components.length === 1 &&  typeof this._last === \"string\") {\n      // \treturn this._last;\n      // }\n      var result = {\n        attachmentsByRange: {},\n        string: \"\"\n      };\n      var hasAttachments = false;\n\n      this._components.forEach(function (component) {\n        if (component instanceof Attachment) {\n          hasAttachments = true;\n          result.attachmentsByRange[\"{\".concat(result.string.length, \", 1}\")] = component.build().Value;\n          result.string += \"\\uFFFC\"; // special character to distinguish variables\n\n          return;\n        }\n\n        if (typeof component === \"string\") {\n          result.string += component;\n          return;\n        }\n\n        throw new Error(\"Invalid component type. This should never happen.\");\n      });\n\n      if (result.string === \"\\uFFFC\" && !hasAttachments) {\n        //eslint-disable-next-line no-console\n        console.log(\"!!!!!result.string is \", result, \" but somehow hasattachments is false\");\n      }\n\n      if (!hasAttachments) {\n        return result.string;\n      }\n\n      return {\n        Value: result,\n        WFSerializationType: \"WFTextTokenString\"\n      };\n    }\n  }, {\n    key: \"_last\",\n    get: function get() {\n      return this._components[this._components.length - 1];\n    }\n  }], [{\n    key: \"inverse\",\n    value: function inverse(data) {\n      var res = new Text();\n\n      if (typeof data === \"string\") {\n        res.add(data);\n      } else {\n        var strPosition = 0;\n        data.Value.string.split(\"\\uFFFC\").forEach(function (textPart) {\n          res.add(textPart);\n          strPosition += textPart.length; // get variable part\n\n          var attachment = data.Value.attachmentsByRange[\"{\".concat(strPosition, \", 1}\")];\n          strPosition++;\n\n          if (!attachment) {\n            return;\n          }\n\n          res.add(Attachment.inverse({\n            WFSerializationType: \"WFTextTokenAttachment\",\n            Value: attachment\n          })); // res.add variable part\n        });\n      }\n\n      return res;\n    }\n  }]);\n\n  return Text;\n}(Parameter);\n\nexports.Text = Text;\n\nvar ErrorParameter =\n/*#__PURE__*/\nfunction (_Parameter7) {\n  _inherits(ErrorParameter, _Parameter7);\n\n  function ErrorParameter(text) {\n    var _this10;\n\n    _classCallCheck(this, ErrorParameter);\n\n    _this10 = _possibleConstructorReturn(this, _getPrototypeOf(ErrorParameter).call(this));\n    _this10.text = text || \"Error. No error message provided\";\n    return _this10;\n  }\n\n  _createClass(ErrorParameter, [{\n    key: \"build\",\n    value: function build() {\n      return {\n        WFSerializationType: \"WFErrorParameter\",\n        Value: {\n          Text: this.text\n        }\n      };\n    }\n  }]);\n\n  return ErrorParameter;\n}(Parameter);\n\nexports.ErrorParameter = ErrorParameter;\n\nfunction toParam(value) {\n  if (typeof value === \"string\") {\n    return value;\n  }\n\n  if (typeof value === \"number\") {\n    return value;\n  }\n\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return List.inverse(value);\n  }\n\n  if (value.WFSerializationType === \"WFTextTokenString\") {\n    return Text.inverse(value);\n  }\n\n  if (value.WFSerializationType === \"WFTextTokenAttachment\") {\n    return Attachment.inverse(value);\n  }\n\n  if (value.WFSerializationType === \"WFDictionaryFieldValue\") {\n    return Dictionary.inverse(value);\n  }\n\n  if (value.WFSerializationType === \"WFTimeOffsetValue\") {\n    return AdjustOffset.inverse(value);\n  }\n\n  if (value.WFSerializationType === \"WFContentPredicateTableTemplate\") {\n    return new ErrorParameter(\"Inversion for filters is not implemented yet.\");\n  }\n\n  if (value.WFSerializationType === \"WFErrorParameter\") {\n    return new ErrorParameter(\"This parameter is an error: \".concat(value.Value.Text));\n  }\n\n  return new ErrorParameter(\"Inversion for this parameter type \".concat(value.WFSerializationType, \" is not implemented yet.\"));\n}\n\nexports.toParam = toParam;\n\nvar Parameters =\n/*#__PURE__*/\nfunction () {\n  function Parameters() {\n    _classCallCheck(this, Parameters);\n\n    this.values = {};\n    this.builtValues = {};\n  }\n\n  _createClass(Parameters, [{\n    key: \"set\",\n    value: function set(internalName, value) {\n      this.values[internalName] = value;\n    }\n  }, {\n    key: \"has\",\n    value: function has(internalName) {\n      return !!this.values[internalName];\n    }\n  }, {\n    key: \"get\",\n    value: function get(internalName) {\n      return this.buildValue(internalName);\n    }\n  }, {\n    key: \"buildValue\",\n    value: function buildValue(key) {\n      if (this.builtValues[key]) {\n        return this.builtValues[key];\n      }\n\n      var value = this.values[key];\n\n      if (value instanceof Parameter) {\n        return value.build();\n      }\n\n      return value;\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      var _this11 = this;\n\n      var result = {};\n      Object.keys(this.values).map(function (key) {\n        result[key] = _this11.buildValue(key);\n      });\n      return result;\n    }\n  }], [{\n    key: \"inverse\",\n    value: function inverse(data) {\n      var parameters = new Parameters();\n      Object.keys(data).forEach(function (paramkey) {\n        parameters.set(paramkey, toParam(data[paramkey])); // why is it being converted just to be unconverted again\n      });\n      return parameters;\n    }\n  }]);\n\n  return Parameters;\n}();\n\nexports.Parameters = Parameters;\n\nvar Action =\n/*#__PURE__*/\nfunction () {\n  function Action(start, end, name, id) {\n    _classCallCheck(this, Action);\n\n    this.name = name;\n    this.id = id;\n    this.parameters = new Parameters();\n    this.magicvarname = undefined;\n    this.start = start;\n    this.end = end;\n  }\n\n  _createClass(Action, [{\n    key: \"build\",\n    value: function build() {\n      if (this.magicvarname) {\n        this.parameters.set(\"CustomOutputName\", this.magicvarname);\n      }\n\n      var res = {\n        WFWorkflowActionIdentifier: this.id,\n        WFWorkflowActionParameters: this.parameters.build()\n      };\n\n      if (this.start && this.end) {\n        res.SCPLData = {\n          Position: {\n            start: this.start,\n            end: this.end\n          }\n        };\n      }\n\n      return res;\n    }\n  }, {\n    key: \"uuid\",\n    get: function get() {\n      if (this.parameters.has(\"UUID\")) {\n        return this.parameters.get(\"UUID\");\n      }\n\n      this.parameters.set(\"UUID\", uuidv4());\n      return this.parameters.get(\"UUID\");\n    }\n  }], [{\n    key: \"inverse\",\n    value: function inverse(data) {\n      var action = new Action(undefined, undefined, undefined, data.WFWorkflowActionIdentifier);\n      action.parameters = Parameters.inverse(data.WFWorkflowActionParameters || {});\n      var customOutputName = action.parameters.get(\"CustomOutputName\");\n\n      if (customOutputName) {\n        action.magicvarname = customOutputName;\n      }\n\n      return action;\n    }\n  }]);\n\n  return Action;\n}();\n\nexports.Action = Action;\n\nvar Shortcut =\n/*#__PURE__*/\nfunction () {\n  function Shortcut(name) {\n    _classCallCheck(this, Shortcut);\n\n    this.name = name;\n    this.actions = [];\n    this.showInWidget = true;\n  }\n\n  _createClass(Shortcut, [{\n    key: \"add\",\n    value: function add(action) {\n      this.actions.push(action);\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      return [{\n        WFWorkflowClientVersion: \"754\",\n        WFWorkflowClientRelese: \"2.1.2\",\n        WFWorkflowMinimumClientVersion: 411,\n        WFWorkflowIcon: {\n          WFWorkflowIconGlyphNumber: this.glyph || ShortcutMeta_1.glyphs.wand,\n          WFWorkflowIconImageData: Buffer.from(\"\"),\n          WFWorkflowIconStartColor: this.color || ShortcutMeta_1.colors.darkpurple\n        },\n        WFWorkflowTypes: [].concat(_toConsumableArray(this.showInWidget ? [\"NCWidget\"] : []), [\"WatchKit\"]),\n        WFWorkflowInputContentItemClasses: [\"WFAppStoreAppContentItem\", \"WFArticleContentItem\", \"WFContactContentItem\", \"WFDateContentItem\", \"WFEmailAddressContentItem\", \"WFGenericFileContentItem\", \"WFImageContentItem\", \"WFiTunesProductContentItem\", \"WFLocationContentItem\", \"WFDCMapsLinkContentItem\", \"WFAVAssetContentItem\", \"WFPDFContentItem\", \"WFPhoneNumberContentItem\", \"WFRichTextContentItem\", \"WFSafariWebPageContentItem\", \"WFStringContentItem\", \"WFURLContentItem\"],\n        WFWorkflowActions: this.actions.map(function (action) {\n          return action.build();\n        })\n      }];\n    }\n  }], [{\n    key: \"inverse\",\n    value: function inverse(data) {\n      var shortcut = new Shortcut(\"inverse\");\n      data[0].WFWorkflowActions.forEach(function (action) {\n        shortcut.add(Action.inverse(action));\n      });\n      var icon = data[0].WFWorkflowIcon;\n\n      if (icon) {\n        shortcut.glyph = icon.WFWorkflowIconGlyphNumber >>> 0;\n\n        if (shortcut.glyph === ShortcutMeta_1.glyphs.wand) {\n          shortcut.glyph = undefined;\n        }\n\n        shortcut.color = icon.WFWorkflowIconStartColor >>> 0;\n\n        if (shortcut.color === ShortcutMeta_1.colors.darkpurple) {\n          shortcut.color = undefined;\n        }\n      }\n\n      return shortcut;\n    }\n  }]);\n\n  return Shortcut;\n}();\n\nexports.Shortcut = Shortcut;","map":null,"metadata":{},"sourceType":"script"}
{"version":3,"file":"file_index.js","sourceRoot":"","sources":["../../../src/generic/file_index.ts"],"names":[],"mappings":"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","sourcesContent":["import {default as Stats, FileType} from '../core/node_fs_stats';\nimport * as path from 'path';\n\n/**\n * A simple class for storing a filesystem index. Assumes that all paths passed\n * to it are *absolute* paths.\n *\n * Can be used as a partial or a full index, although care must be taken if used\n * for the former purpose, especially when directories are concerned.\n */\nexport class FileIndex<T> {\n  /**\n   * Static method for constructing indices from a JSON listing.\n   * @param listing Directory listing generated by tools/XHRIndexer.coffee\n   * @return A new FileIndex object.\n   */\n  public static fromListing<T>(listing: any): FileIndex<T> {\n    const idx = new FileIndex<T>();\n    // Add a root DirNode.\n    const rootInode = new DirInode<T>();\n    idx._index['/'] = rootInode;\n    const queue = [['', listing, rootInode]];\n    while (queue.length > 0) {\n      let inode: Inode;\n      const next = queue.pop();\n      const pwd = next![0];\n      const tree = next![1];\n      const parent = next![2];\n      for (const node in tree) {\n        if (tree.hasOwnProperty(node)) {\n          const children = tree[node];\n          const name = `${pwd}/${node}`;\n          if (children) {\n            idx._index[name] = inode = new DirInode<T>();\n            queue.push([name, children, inode]);\n          } else {\n            // This inode doesn't have correct size information, noted with -1.\n            inode = new FileInode<Stats>(new Stats(FileType.FILE, -1, 0x16D));\n          }\n          if (parent) {\n            parent._ls[node] = inode;\n          }\n        }\n      }\n    }\n    return idx;\n  }\n\n  // Maps directory paths to directory inodes, which contain files.\n  private _index: {[path: string]: DirInode<T> };\n\n  /**\n   * Constructs a new FileIndex.\n   */\n  constructor() {\n    // _index is a single-level key,value store that maps *directory* paths to\n    // DirInodes. File information is only contained in DirInodes themselves.\n    this._index = {};\n    // Create the root directory.\n    this.addPath('/', new DirInode());\n  }\n\n  /**\n   * Runs the given function over all files in the index.\n   */\n  public fileIterator<T>(cb: (file: T | null) => void): void {\n    for (const path in this._index) {\n      if (this._index.hasOwnProperty(path)) {\n        const dir = this._index[path];\n        const files = dir.getListing();\n        for (const file of files) {\n          const item = dir.getItem(file);\n          if (isFileInode<T>(item)) {\n            cb(item.getData());\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Adds the given absolute path to the index if it is not already in the index.\n   * Creates any needed parent directories.\n   * @param path The path to add to the index.\n   * @param inode The inode for the\n   *   path to add.\n   * @return 'True' if it was added or already exists, 'false' if there\n   *   was an issue adding it (e.g. item in path is a file, item exists but is\n   *   different).\n   * @todo If adding fails and implicitly creates directories, we do not clean up\n   *   the new empty directories.\n   */\n  public addPath(path: string, inode: Inode): boolean {\n    if (!inode) {\n      throw new Error('Inode must be specified');\n    }\n    if (path[0] !== '/') {\n      throw new Error('Path must be absolute, got: ' + path);\n    }\n\n    // Check if it already exists.\n    if (this._index.hasOwnProperty(path)) {\n      return this._index[path] === inode;\n    }\n\n    const splitPath = this._split_path(path);\n    const dirpath = splitPath[0];\n    const itemname = splitPath[1];\n    // Try to add to its parent directory first.\n    let parent = this._index[dirpath];\n    if (parent === undefined && path !== '/') {\n      // Create parent.\n      parent = new DirInode<T>();\n      if (!this.addPath(dirpath, parent)) {\n        return false;\n      }\n    }\n    // Add myself to my parent.\n    if (path !== '/') {\n      if (!parent.addItem(itemname, inode)) {\n        return false;\n      }\n    }\n    // If I'm a directory, add myself to the index.\n    if (isDirInode<T>(inode)) {\n      this._index[path] = inode;\n    }\n    return true;\n  }\n\n  /**\n   * Adds the given absolute path to the index if it is not already in the index.\n   * The path is added without special treatment (no joining of adjacent separators, etc).\n   * Creates any needed parent directories.\n   * @param path The path to add to the index.\n   * @param inode The inode for the\n   *   path to add.\n   * @return 'True' if it was added or already exists, 'false' if there\n   *   was an issue adding it (e.g. item in path is a file, item exists but is\n   *   different).\n   * @todo If adding fails and implicitly creates directories, we do not clean up\n   *   the new empty directories.\n   */\n  public addPathFast(path: string, inode: Inode): boolean {\n    const itemNameMark = path.lastIndexOf('/');\n    const parentPath = itemNameMark === 0 ? \"/\" : path.substring(0, itemNameMark);\n    const itemName = path.substring(itemNameMark + 1);\n\n    // Try to add to its parent directory first.\n    let parent = this._index[parentPath];\n    if (parent === undefined) {\n      // Create parent.\n      parent = new DirInode<T>();\n      this.addPathFast(parentPath, parent);\n    }\n\n    if (!parent.addItem(itemName, inode)) {\n      return false;\n    }\n\n    // If adding a directory, add to the index as well.\n    if (inode.isDir()) {\n      this._index[path] = <DirInode<T>> inode;\n    }\n    return true;\n  }\n\n  /**\n   * Removes the given path. Can be a file or a directory.\n   * @return The removed item,\n   *   or null if it did not exist.\n   */\n  public removePath(path: string): Inode | null {\n    const splitPath = this._split_path(path);\n    const dirpath = splitPath[0];\n    const itemname = splitPath[1];\n\n    // Try to remove it from its parent directory first.\n    const parent = this._index[dirpath];\n    if (parent === undefined) {\n      return null;\n    }\n    // Remove myself from my parent.\n    const inode = parent.remItem(itemname);\n    if (inode === null) {\n      return null;\n    }\n    // If I'm a directory, remove myself from the index, and remove my children.\n    if (isDirInode(inode)) {\n      const children = inode.getListing();\n      for (const child of children) {\n        this.removePath(path + '/' + child);\n      }\n\n      // Remove the directory from the index, unless it's the root.\n      if (path !== '/') {\n        delete this._index[path];\n      }\n    }\n    return inode;\n  }\n\n  /**\n   * Retrieves the directory listing of the given path.\n   * @return An array of files in the given path, or 'null' if it does not exist.\n   */\n  public ls(path: string): string[] | null {\n    const item = this._index[path];\n    if (item === undefined) {\n      return null;\n    }\n    return item.getListing();\n  }\n\n  /**\n   * Returns the inode of the given item.\n   * @return Returns null if the item does not exist.\n   */\n  public getInode(path: string): Inode | null {\n    const splitPath = this._split_path(path);\n    const dirpath = splitPath[0];\n    const itemname = splitPath[1];\n    // Retrieve from its parent directory.\n    const parent = this._index[dirpath];\n    if (parent === undefined) {\n      return null;\n    }\n    // Root case\n    if (dirpath === path) {\n      return parent;\n    }\n    return parent.getItem(itemname);\n  }\n\n  /**\n   * Split into a (directory path, item name) pair\n   */\n  private _split_path(p: string): string[] {\n    const dirpath = path.dirname(p);\n    const itemname = p.substr(dirpath.length + (dirpath === \"/\" ? 0 : 1));\n    return [dirpath, itemname];\n  }\n}\n\n/**\n * Generic interface for file/directory inodes.\n * Note that Stats objects are what we use for file inodes.\n */\nexport interface Inode {\n  // Is this an inode for a file?\n  isFile(): boolean;\n  // Is this an inode for a directory?\n  isDir(): boolean;\n}\n\n/**\n * Inode for a file. Stores an arbitrary (filesystem-specific) data payload.\n */\nexport class FileInode<T> implements Inode {\n  constructor(private data: T) { }\n  public isFile(): boolean { return true; }\n  public isDir(): boolean { return false; }\n  public getData(): T { return this.data; }\n  public setData(data: T): void { this.data = data; }\n}\n\n/**\n * Inode for a directory. Currently only contains the directory listing.\n */\nexport class DirInode<T> implements Inode {\n  private _ls: {[path: string]: Inode} = {};\n  /**\n   * Constructs an inode for a directory.\n   */\n  constructor(private data: T | null = null) {}\n  public isFile(): boolean {\n    return false;\n  }\n  public isDir(): boolean {\n    return true;\n  }\n  public getData(): T | null { return this.data; }\n\n  /**\n   * Return a Stats object for this inode.\n   * @todo Should probably remove this at some point. This isn't the\n   *       responsibility of the FileIndex.\n   */\n  public getStats(): Stats {\n    return new Stats(FileType.DIRECTORY, 4096, 0x16D);\n  }\n  /**\n   * Returns the directory listing for this directory. Paths in the directory are\n   * relative to the directory's path.\n   * @return The directory listing for this directory.\n   */\n  public getListing(): string[] {\n    return Object.keys(this._ls);\n  }\n  /**\n   * Returns the inode for the indicated item, or null if it does not exist.\n   * @param p Name of item in this directory.\n   */\n  public getItem(p: string): Inode | null {\n    const item = this._ls[p];\n    return item ? item : null;\n  }\n  /**\n   * Add the given item to the directory listing. Note that the given inode is\n   * not copied, and will be mutated by the DirInode if it is a DirInode.\n   * @param p Item name to add to the directory listing.\n   * @param inode The inode for the\n   *   item to add to the directory inode.\n   * @return True if it was added, false if it already existed.\n   */\n  public addItem(p: string, inode: Inode): boolean {\n    if (p in this._ls) {\n      return false;\n    }\n    this._ls[p] = inode;\n    return true;\n  }\n  /**\n   * Removes the given item from the directory listing.\n   * @param p Name of item to remove from the directory listing.\n   * @return Returns the item\n   *   removed, or null if the item did not exist.\n   */\n  public remItem(p: string): Inode | null {\n    const item = this._ls[p];\n    if (item === undefined) {\n      return null;\n    }\n    delete this._ls[p];\n    return item;\n  }\n}\n\n/**\n * @hidden\n */\nexport function isFileInode<T>(inode: Inode | null): inode is FileInode<T> {\n  return !!inode && inode.isFile();\n}\n\n/**\n * @hidden\n */\nexport function isDirInode<T>(inode: Inode | null): inode is DirInode<T> {\n  return !!inode && inode.isDir();\n}\n"]}
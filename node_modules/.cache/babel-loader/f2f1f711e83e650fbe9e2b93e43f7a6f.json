{"ast":null,"code":"\"use strict\";\n\nvar _construct = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/construct\");\n\nvar _toConsumableArray = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _possibleConstructorReturn = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _classCallCheck = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar OutputData_1 = require(\"./OutputData\");\n\nvar ActionData_1 = require(\"./ActionData\");\n\nvar Converter_1 = require(\"./Converter\");\n\nvar HelpfulActions_1 = require(\"./HelpfulActions\");\n\nvar HelpfulActions_2 = require(\"./HelpfulActions\");\n\nvar Types_1 = require(\"./WFTypes/Types\");\n\nvar nearestString_1 = require(\"./nearestString\");\n\nvar GetTypes_1 = require(\"./Data/GetTypes\");\n\nvar PositionedError_1 = require(\"./PositionedError\");\n\nvar PositionedError_2 = require(\"./PositionedError\");\n\nexports.PositionedError = PositionedError_2.PositionedError;\n\nvar uuidv4 = require(\"uuid/v4\");\n\nvar Parse =\n/*#__PURE__*/\nfunction () {\n  function Parse(start, end) {\n    _classCallCheck(this, Parse);\n\n    this.start = start;\n    this.end = end;\n  }\n\n  _createClass(Parse, [{\n    key: \"error\",\n    value: function error(_cc, message) {\n      return new PositionedError_1.PositionedError(message, this.start, this.end);\n    }\n  }, {\n    key: \"warn\",\n    value: function warn(cc, message) {\n      return cc.warn(new PositionedError_1.PositionedError(message, this.start, this.end));\n    }\n  }, {\n    key: \"canBeString\",\n    value: function canBeString(_cc) {\n      return false;\n    }\n  }, {\n    key: \"canBeBoolean\",\n    value: function canBeBoolean(_cc) {\n      return false;\n    }\n  }, {\n    key: \"canBeText\",\n    value: function canBeText(_cc) {\n      return false;\n    }\n  }, {\n    key: \"canBeList\",\n    value: function canBeList(_cc) {\n      return false;\n    }\n  }, {\n    key: \"canBeArray\",\n    value: function canBeArray(_cc) {\n      return false;\n    }\n  }, {\n    key: \"canBeAbleArray\",\n    value: function canBeAbleArray(_cc) {\n      return false;\n    }\n  }, {\n    key: \"canBeVariable\",\n    value: function canBeVariable(_cc) {\n      return false;\n    }\n  }, {\n    key: \"canBeAction\",\n    value: function canBeAction(_cc) {\n      return false;\n    }\n  }, {\n    key: \"canBeDictionary\",\n    value: function canBeDictionary(_cc) {\n      return false;\n    }\n  }, {\n    key: \"canBeRawDictionary\",\n    value: function canBeRawDictionary(_cc) {\n      return false;\n    }\n  }, {\n    key: \"canBeRawKeyedDictionary\",\n    value: function canBeRawKeyedDictionary(_cc) {\n      return false;\n    }\n  }, {\n    key: \"canBeNameType\",\n    value: function canBeNameType(_cc) {\n      return false;\n    }\n  }, {\n    key: \"canBeStringVariable\",\n    value: function canBeStringVariable(_cc) {\n      return false;\n    }\n  }, {\n    key: \"canBeNumber\",\n    value: function canBeNumber(_cc) {\n      return false;\n    }\n  }, {\n    key: \"canBeFilter\",\n    value: function canBeFilter(_cc) {\n      return false;\n    }\n  }, {\n    key: \"canBeFilterItem\",\n    value: function canBeFilterItem(_cc) {\n      return false;\n    }\n  }, {\n    key: \"canBePreprocessorVariableName\",\n    value: function canBePreprocessorVariableName(_cc) {\n      return false;\n    }\n  }, {\n    key: \"canBeTimeOffsetParameter\",\n    value: function canBeTimeOffsetParameter(_cc) {\n      return false;\n    }\n  }]);\n\n  return Parse;\n}();\n\nexports.Parse = Parse;\nvar ilist = [\"String\", \"Boolean\", \"Text\", \"List\", \"Array\", \"AbleArray\", \"Variable\", \"Action\", \"Dictionary\", \"RawDictionary\", \"RawKeyedDictionary\", \"NameType\", \"StringVariable\", \"Number\", \"Filter\", \"FilterItem\", \"TimeOffsetParameter\" // not PreprocessorVariableName\n];\n\nvar ConvertVariableParse =\n/*#__PURE__*/\nfunction (_Parse) {\n  _inherits(ConvertVariableParse, _Parse);\n\n  function ConvertVariableParse(start, end, name, options) {\n    var _this;\n\n    _classCallCheck(this, ConvertVariableParse);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ConvertVariableParse).call(this, start, end));\n    _this.name = name;\n    _this.options = options;\n    return _this;\n  }\n\n  _createClass(ConvertVariableParse, [{\n    key: \"canBePreprocessorVariableName\",\n    value: function canBePreprocessorVariableName(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asPreprocessorVariableName\",\n    value: function asPreprocessorVariableName(cc) {\n      if (!this.name.canBeString(cc)) {\n        throw this.name.error(cc, \"Name must be a string with no variables.\");\n      }\n\n      var name = this.name.asString(cc);\n      return name;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue(cc) {\n      var name = this.asPreprocessorVariableName(cc);\n      var me = cc.getParserVariable(name);\n\n      if (!me) {\n        throw _get(_getPrototypeOf(ConvertVariableParse.prototype), \"error\", this).call(this, cc, \"Parser Variable @:\".concat(name, \" is not defined.\"));\n      }\n\n      return me;\n    }\n  }, {\n    key: \"error\",\n    value: function error(cc, message) {\n      var me = this.getValue(cc);\n      return me.error(cc, \"\".concat(this.start, \" \").concat(this.end, \" \").concat(message));\n    }\n  }, {\n    key: \"warn\",\n    value: function warn(cc, message) {\n      var me = this.getValue(cc);\n      return me.warn(cc, \"\".concat(this.start, \" \").concat(this.end, \" \").concat(message));\n    }\n  }]);\n\n  return ConvertVariableParse;\n}(Parse);\n\nexports.ConvertVariableParse = ConvertVariableParse; // there has to be a better way\n\nilist.forEach(function (val) {\n  //eslint-disable-next-line func-names\n  ConvertVariableParse.prototype[\"canBe\".concat(val)] = function (cc) {\n    var me = this.getValue(cc);\n    return me[\"canBe\".concat(val)](cc);\n  }; //eslint-disable-next-line func-names\n\n\n  ConvertVariableParse.prototype[\"as\".concat(val)] = function (cc) {\n    var me = this.getValue(cc);\n    var options = this.options;\n    var rawKeyedOptions;\n\n    if (!options) {\n      rawKeyedOptions = {};\n    } else if (options.canBeRawKeyedDictionary(cc)) {\n      rawKeyedOptions = options.asRawKeyedDictionary(cc);\n    } else {\n      throw options.error(cc, \"Options must be a dictionary.\");\n    } // here we want to make a new cc on top of the old one\n\n\n    var newCC = cc.in();\n    Object.keys(rawKeyedOptions).forEach(function (key) {\n      var value = rawKeyedOptions[key];\n      newCC.setParserVariable(key, value);\n    });\n\n    for (var _len = arguments.length, extraData = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      extraData[_key - 1] = arguments[_key];\n    }\n\n    return me[\"as\".concat(val)].apply(me, [newCC].concat(extraData));\n  };\n});\n\nvar ErrorParse =\n/*#__PURE__*/\nfunction (_Parse2) {\n  _inherits(ErrorParse, _Parse2);\n\n  function ErrorParse(start, end, _message) {\n    _classCallCheck(this, ErrorParse);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ErrorParse).call(this, start, end));\n  }\n\n  return ErrorParse;\n}(Parse);\n\nexports.ErrorParse = ErrorParse;\n\nvar FilterParse =\n/*#__PURE__*/\nfunction (_Parse3) {\n  _inherits(FilterParse, _Parse3);\n\n  function FilterParse(start, end, mode, filterItems) {\n    var _this2;\n\n    _classCallCheck(this, FilterParse);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(FilterParse).call(this, start, end));\n    _this2.filterItems = filterItems;\n    _this2.mode = mode;\n    return _this2;\n  }\n\n  _createClass(FilterParse, [{\n    key: \"canBeFilter\",\n    value: function canBeFilter(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asFilter\",\n    value: function asFilter(cc, type) {\n      var filter = new OutputData_1.ContentItemFilter(type, this.mode);\n      this.filterItems.forEach(function (filterItem) {\n        if (!filterItem.canBeFilterItem(cc)) {\n          throw filterItem.error(cc, \"This item is not a filter item.\");\n        }\n\n        filterItem.asFilterItem(cc, filter);\n      });\n      return filter;\n    }\n  }]);\n\n  return FilterParse;\n}(Parse);\n\nexports.FilterParse = FilterParse;\n\nvar FilterItemParse =\n/*#__PURE__*/\nfunction (_Parse4) {\n  _inherits(FilterItemParse, _Parse4);\n\n  function FilterItemParse(start, end, property, operator, value, units) {\n    var _this3;\n\n    _classCallCheck(this, FilterItemParse);\n\n    // property: string, oiperatornl/ ;''\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(FilterItemParse).call(this, start, end));\n    _this3.property = property;\n    _this3.operator = operator;\n    _this3.value = value;\n    _this3.units = units;\n    return _this3;\n  }\n\n  _createClass(FilterItemParse, [{\n    key: \"canBeFilterItem\",\n    value: function canBeFilterItem(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asFilterItem\",\n    value: function asFilterItem(cc, filter) {\n      if (!this.property.canBeString(cc)) {\n        throw this.property.error(cc, \"Property must be a string\");\n      }\n\n      var property = ActionData_1.genShortName(this.property.asString(cc));\n\n      if (!Types_1.isAggrandizementPropertyName(property)) {\n        throw this.property.error(cc, \"Property must be a property name.\");\n      }\n\n      var propertyName = property;\n\n      if (!this.operator.canBeString(cc)) {\n        throw this.property.error(cc, \"Operator must be a string\");\n      }\n\n      var operator = ActionData_1.genShortName(this.operator.asString(cc));\n\n      if (!GetTypes_1.isComparisonMethod(operator)) {\n        throw this.property.error(cc, \"Property must be a comparison method.\");\n      }\n\n      var operatorName = operator;\n      var typeInfo = filter.getTypeInfo({\n        property: propertyName,\n        operator: operatorName\n      });\n\n      if (typeInfo.error) {\n        throw this.error(cc, typeInfo.message);\n      }\n\n      var value;\n\n      if (typeInfo.expectedType === \"stringOrText\") {\n        if (!this.value.canBeText(cc)) {\n          throw this.property.error(cc, \"Value must be a string\");\n        }\n\n        value = this.value.asText(cc);\n      } else if (typeInfo.expectedType === \"string\") {\n        if (!this.value.canBeString(cc)) {\n          throw this.property.error(cc, \"Value must be a string\");\n        }\n\n        value = this.value.asString(cc);\n      } else if (typeInfo.expectedType === \"number\") {\n        if (!this.value.canBeNumber(cc)) {\n          throw this.property.error(cc, \"Value must be a number\");\n        }\n\n        value = this.value.asNumber(cc);\n      } else if (typeInfo.expectedType === \"boolean\") {\n        if (!this.value.canBeBoolean(cc)) {\n          throw this.property.error(cc, \"Value must be a boolean\");\n        }\n\n        value = this.value.asBoolean(cc);\n      }\n\n      if (value === undefined) {\n        throw this.error(cc, \"Value is unknown. This should never happen.\");\n      }\n\n      if (this.units) {\n        throw this.units.error(cc, \"Units are not implemented yet\");\n      }\n\n      var addResult = filter.add(value, typeInfo.typeData);\n\n      if (typeof addResult === \"string\") {\n        throw this.error(cc, addResult);\n      }\n    }\n  }]);\n\n  return FilterItemParse;\n}(Parse);\n\nexports.FilterItemParse = FilterItemParse;\n\nvar DictionaryParse =\n/*#__PURE__*/\nfunction (_Parse5) {\n  _inherits(DictionaryParse, _Parse5);\n\n  function DictionaryParse(start, end, keyvaluepairs) {\n    var _this4;\n\n    _classCallCheck(this, DictionaryParse);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(DictionaryParse).call(this, start, end));\n    _this4.keyvaluepairs = keyvaluepairs;\n    return _this4;\n  }\n\n  _createClass(DictionaryParse, [{\n    key: \"canBeRawDictionary\",\n    value: function canBeRawDictionary(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asRawDictionary\",\n    value: function asRawDictionary(cc) {\n      // for static things that cannot have interpolated keys or values\n      var dictionary = {};\n      this.keyvaluepairs.forEach(function (_ref) {\n        var key = _ref.key,\n            value = _ref.value,\n            type = _ref.type;\n\n        if (type) {\n          throw type.error(cc, \"This dictionary can not have a type.\");\n        }\n\n        if (!key.canBeString(cc)) {\n          throw key.error(cc, \"This key name must be a string with no variables.\");\n        }\n\n        if (!value.canBeString(cc)) {\n          throw value.error(cc, \"This value must be a string with no variables.\");\n        }\n\n        var stringKey = key.asString(cc);\n\n        if (dictionary[stringKey]) {\n          throw key.error(cc, \"This key was already defined in this dictionary.\");\n        }\n\n        dictionary[stringKey] = value.asString(cc);\n      });\n      return dictionary;\n    }\n  }, {\n    key: \"canBeRawKeyedDictionary\",\n    value: function canBeRawKeyedDictionary(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asRawKeyedDictionary\",\n    value: function asRawKeyedDictionary(cc) {\n      // returns a raw dictionary (keys are raw, not values) for this DictionaryParse\n      var dictionary = {};\n      this.keyvaluepairs.forEach(function (_ref2) {\n        var key = _ref2.key,\n            value = _ref2.value;\n\n        if (!key.canBeString(cc)) {\n          throw key.error(cc, \"This key name must be a string with no variables.\");\n        }\n\n        var stringKey = key.asString(cc);\n\n        if (dictionary[stringKey]) {\n          throw key.error(cc, \"This key name was already defined in this dictionary.\");\n        }\n\n        dictionary[stringKey] = value;\n      });\n      return dictionary;\n    }\n  }, {\n    key: \"canBeDictionary\",\n    value: function canBeDictionary(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asDictionary\",\n    value: function asDictionary(cc) {\n      // returns an Output Dictionary for this DictionaryParse\n      var dictionary = new OutputData_1.Dictionary(); //eslint-disable-next-line complexity\n\n      this.keyvaluepairs.forEach(function (_ref3) {\n        var key = _ref3.key,\n            value = _ref3.value,\n            type = _ref3.type;\n        var typeStr = \"auto\";\n\n        if (type) {\n          if (!type.canBeString(cc)) {\n            throw key.error(cc, \"Type must be string.\");\n          }\n\n          var validTypeStr = type.asString(cc);\n\n          if (validTypeStr === \"bool\") {\n            validTypeStr = \"boolean\";\n          }\n\n          if (validTypeStr === \"array\") {\n            validTypeStr = \"list\";\n          }\n\n          if (validTypeStr !== \"text\" && validTypeStr !== \"number\" && validTypeStr !== \"boolean\" && validTypeStr !== \"list\" && validTypeStr !== \"dictionary\" && validTypeStr !== \"file\") {\n            throw type.error(cc, \"Must be text|number|boolean|array|dictionary|file\");\n          }\n\n          typeStr = validTypeStr;\n        }\n\n        var outputValue;\n\n        if (!key.canBeText(cc)) {\n          throw key.error(cc, \"Dictionary keys must be texts\");\n        }\n\n        var keyText = key.asText(cc);\n\n        if (typeStr === \"auto\") {\n          if (value.canBeList(cc)) {\n            outputValue = value.asList(cc);\n          } else if (value.canBeDictionary(cc)) {\n            outputValue = value.asDictionary(cc);\n          } else if (value.canBeText(cc)) {\n            outputValue = value.asText(cc);\n          } else {\n            throw value.error(cc, \"This value must be a list, string, or dictionary.\");\n          }\n        } else if (typeStr === \"text\") {\n          if (value.canBeText(cc)) {\n            outputValue = value.asText(cc);\n          } else {\n            throw value.error(cc, \"This value must be a text.\");\n          }\n        } else if (typeStr === \"number\") {\n          if (value.canBeNumber(cc)) {\n            outputValue = value.asNumber(cc);\n          } else {\n            throw value.error(cc, \"This value must be a number.\");\n          }\n        } else if (typeStr === \"boolean\") {\n          if (value.canBeBoolean(cc)) {\n            outputValue = value.asBoolean(cc);\n          } else {\n            throw value.error(cc, \"This value must be a boolean.\");\n          }\n        } else if (typeStr === \"list\") {\n          if (value.canBeList(cc)) {\n            outputValue = value.asList(cc);\n          } else {\n            throw value.error(cc, \"This value must be a list.\");\n          }\n        } else if (typeStr === \"dictionary\") {\n          if (value.canBeDictionary(cc)) {\n            outputValue = value.asDictionary(cc);\n          } else {\n            throw value.error(cc, \"This value must be a dictionary.\");\n          }\n        } else if (typeStr === \"file\") {\n          if (value.canBeVariable(cc)) {\n            outputValue = value.asVariable(cc);\n          } else {\n            throw value.error(cc, \"This value must be a variable.\");\n          }\n        }\n\n        if (outputValue === undefined) {\n          throw value.error(cc, \"Output value does not exist. This should never happen.\");\n        }\n\n        dictionary.add(keyText, outputValue);\n      });\n      return dictionary;\n    }\n  }]);\n\n  return DictionaryParse;\n}(Parse);\n\nexports.DictionaryParse = DictionaryParse;\n\nvar ListParse =\n/*#__PURE__*/\nfunction (_Parse6) {\n  _inherits(ListParse, _Parse6);\n\n  function ListParse(start, end, items) {\n    var _this5;\n\n    _classCallCheck(this, ListParse);\n\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(ListParse).call(this, start, end));\n    _this5.items = items;\n    return _this5;\n  }\n\n  _createClass(ListParse, [{\n    key: \"canBeArray\",\n    value: function canBeArray(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asArray\",\n    value: function asArray(cc) {\n      // -> \"\"[]\n      return this.items.map(function (item) {\n        if (!item.canBeString(cc)) {\n          throw item.error(cc, \"This list can only contain strings with no variables.\");\n        }\n\n        return item.asString(cc);\n      });\n    }\n  }, {\n    key: \"canBeAbleArray\",\n    value: function canBeAbleArray(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asAbleArray\",\n    value: function asAbleArray(_cc) {\n      return this.items;\n    }\n  }, {\n    key: \"canBeList\",\n    value: function canBeList(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asList\",\n    value: function asList(cc) {\n      // -> Text[]\n      return new OutputData_1.List(this.items.map(function (item) {\n        if (!item.canBeText(cc)) {\n          throw item.error(cc, \"This list can only contain strings.\");\n        }\n\n        return item.asText(cc);\n      }));\n    }\n  }, {\n    key: \"canBeTimeOffsetParameter\",\n    value: function canBeTimeOffsetParameter(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asTimeOffsetParameter\",\n    value: function asTimeOffsetParameter(cc) {\n      var i0 = this.items[0];\n\n      if (!i0) {\n        throw this.error(cc, \"List must contain at least one item.\");\n      }\n\n      if (!i0.canBeString(cc)) {\n        throw i0.error(cc, \"Must be string\");\n      }\n\n      var i0str = i0.asString(cc);\n\n      if (i0str.toLowerCase() === \"get\" || this.items.length === 0) {\n        // 1\n        var fullStr = this.items.map(function (i) {\n          if (!i.canBeString(cc)) {\n            throw i.error(cc, \"Must be string with no variables\");\n          }\n\n          return i.asString(cc);\n        }).join(\" \");\n        var timeoffsetvalueenum = nearestString_1.nearestString(fullStr, OutputData_1.WFTimeOffsetValueEnumList);\n\n        if (!timeoffsetvalueenum) {\n          throw this.error(cc, \"Expected one of: `\".concat(OutputData_1.WFTimeOffsetValueEnumList.join(), \"`\"));\n        }\n\n        var adjustOffset = new OutputData_1.AdjustOffset({\n          v: \"onearg\",\n          mode: timeoffsetvalueenum\n        });\n        return adjustOffset;\n      }\n\n      if (this.items.length !== 3) {\n        throw this.error(cc, \"List must contain exactly three items, [Mode Count Unit]\");\n      }\n\n      var timeoffsetvalueaddsub = nearestString_1.nearestString(i0str, [\"Add\", \"Subtract\"]);\n\n      if (!timeoffsetvalueaddsub) {\n        throw i0.error(cc, \"Must be Add | Subtract\");\n      }\n\n      var i2 = this.items[2];\n\n      if (!i2) {\n        throw this.error(cc, \"List must contain at least one item.\");\n      }\n\n      if (!i2.canBeString(cc)) {\n        throw i2.error(cc, \"Must be string\");\n      }\n\n      var i2str = i2.asString(cc);\n      var timeoffsetvalueunit = nearestString_1.nearestString(i2str, OutputData_1.WFTimeOffsetValueUnitList);\n\n      if (!timeoffsetvalueunit) {\n        throw i2.error(cc, \"Expected one of: `\".concat(OutputData_1.WFTimeOffsetValueUnitList.join(), \"`\"));\n      }\n\n      var value;\n      var i1 = this.items[1];\n\n      if (i1.canBeNumber(cc)) {\n        value = i1.asNumber(cc);\n      } else if (i1.canBeVariable(cc)) {\n        value = i1.asVariable(cc);\n      } else {\n        throw i1.error(cc, \"Must be number or variable\");\n      }\n\n      return new OutputData_1.AdjustOffset({\n        v: \"threearg\",\n        mode: timeoffsetvalueaddsub,\n        unit: timeoffsetvalueunit,\n        value: value\n      });\n    }\n  }]);\n\n  return ListParse;\n}(Parse);\n\nexports.ListParse = ListParse;\n\nvar BarlistParse =\n/*#__PURE__*/\nfunction (_ListParse) {\n  _inherits(BarlistParse, _ListParse);\n\n  function BarlistParse() {\n    _classCallCheck(this, BarlistParse);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BarlistParse).apply(this, arguments));\n  }\n\n  _createClass(BarlistParse, [{\n    key: \"canBeString\",\n    value: function canBeString(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asString\",\n    value: function asString(cc) {\n      return this.items.map(function (item) {\n        if (!item.canBeString(cc)) {\n          throw item.error(cc, \"This barlist can only contain strings with no variables.\");\n        }\n\n        return item.asString(cc);\n      }).join(\"\\n\");\n    }\n  }, {\n    key: \"canBeText\",\n    value: function canBeText(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asText\",\n    value: function asText(cc) {\n      var _this6 = this;\n\n      // -> Text\n      var finalText = new OutputData_1.Text();\n      this.items.forEach(function (item, i) {\n        if (!item.canBeText(cc)) {\n          throw item.error(cc, \"This barlist can only contain strings.\");\n        }\n\n        finalText.add(item.asText(cc));\n\n        if (_this6.items.length - 1 !== i) {\n          finalText.add(\"\\n\");\n        }\n      }); // this.data.join`\\n` but for non-strings\n      // finalText.add(...this.data.items.map(i=>i.asText()));\n\n      return finalText;\n    }\n  }, {\n    key: \"canBeTimeOffsetParameter\",\n    value: function canBeTimeOffsetParameter(_cc) {\n      return false;\n    }\n  }]);\n\n  return BarlistParse;\n}(ListParse);\n\nexports.BarlistParse = BarlistParse;\n\nvar CharsParse =\n/*#__PURE__*/\nfunction (_Parse7) {\n  _inherits(CharsParse, _Parse7);\n\n  function CharsParse(start, end, items) {\n    var _this7;\n\n    _classCallCheck(this, CharsParse);\n\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(CharsParse).call(this, start, end));\n    _this7.items = items;\n    return _this7;\n  }\n\n  _createClass(CharsParse, [{\n    key: \"canBeString\",\n    value: function canBeString(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asString\",\n    value: function asString(cc) {\n      // returns a raw string\n      var string = \"\";\n      this.items.forEach(function (item) {\n        if (typeof item === \"string\") {\n          string += item;\n          return;\n        }\n\n        if (item instanceof ConvertVariableParse) {\n          if (item.canBeString(cc)) {\n            string += item.asString(cc);\n            return;\n          }\n        }\n\n        throw item.error(cc, \"This string is not allowed to have variables.\");\n      });\n      return string;\n    }\n  }, {\n    key: \"canBeNumber\",\n    value: function canBeNumber(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asNumber\",\n    value: function asNumber(cc) {\n      var num = +this.asString(cc);\n\n      if (isNaN(num)) {\n        throw this.error(cc, \"This number could not be converted to a number.\");\n      }\n\n      return num;\n    }\n  }, {\n    key: \"canBeText\",\n    value: function canBeText(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asText\",\n    value: function asText(cc) {\n      var text = new OutputData_1.Text();\n      this.items.forEach(function (item) {\n        if (typeof item === \"string\") {\n          return text.add(item);\n        }\n\n        if (item instanceof ConvertVariableParse) {\n          if (item.canBeText(cc)) {\n            text.add(item.asText(cc));\n            return;\n          }\n        }\n\n        if (!item.canBeVariable(cc)) {\n          throw item.error(cc, \"String interpolations can only contain variables.\");\n        }\n\n        return text.add(item.asVariable(cc));\n      });\n      return text;\n    }\n  }]);\n\n  return CharsParse;\n}(Parse);\n\nexports.CharsParse = CharsParse;\n\nvar IdentifierParse =\n/*#__PURE__*/\nfunction (_Parse8) {\n  _inherits(IdentifierParse, _Parse8);\n\n  function IdentifierParse(start, end, str) {\n    var _this8;\n\n    _classCallCheck(this, IdentifierParse);\n\n    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(IdentifierParse).call(this, start, end));\n    _this8.value = str;\n    return _this8;\n  }\n\n  _createClass(IdentifierParse, [{\n    key: \"canBeString\",\n    value: function canBeString(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asString\",\n    value: function asString(_cc) {\n      return this.value;\n    }\n  }, {\n    key: \"canBeNumber\",\n    value: function canBeNumber(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asNumber\",\n    value: function asNumber(cc) {\n      var num = +this.value;\n\n      if (isNaN(num)) {\n        throw this.error(cc, \"This number could not be converted to a number.\");\n      }\n\n      return num;\n    }\n  }, {\n    key: \"canBeBoolean\",\n    value: function canBeBoolean(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asBoolean\",\n    value: function asBoolean(cc) {\n      var string = this.asString(cc);\n\n      if (string === \"true\") {\n        return true;\n      }\n\n      if (string === \"false\") {\n        return false;\n      }\n\n      throw this.error(cc, \"This boolean must be either true or false.\");\n    }\n  }, {\n    key: \"canBeText\",\n    value: function canBeText(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asText\",\n    value: function asText(_cc) {\n      var text = new OutputData_1.Text();\n      text.add(this.value);\n      return text;\n    }\n  }]);\n\n  return IdentifierParse;\n}(Parse);\n\nexports.IdentifierParse = IdentifierParse;\n\nvar NumberParse =\n/*#__PURE__*/\nfunction (_IdentifierParse) {\n  _inherits(NumberParse, _IdentifierParse);\n\n  function NumberParse() {\n    _classCallCheck(this, NumberParse);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(NumberParse).apply(this, arguments));\n  }\n\n  return NumberParse;\n}(IdentifierParse);\n\nexports.NumberParse = NumberParse;\n\nvar ArglistParse =\n/*#__PURE__*/\nfunction (_DictionaryParse) {\n  _inherits(ArglistParse, _DictionaryParse);\n\n  function ArglistParse(start, end, keyValuePairs) {\n    var _this9;\n\n    _classCallCheck(this, ArglistParse);\n\n    _this9 = _possibleConstructorReturn(this, _getPrototypeOf(ArglistParse).call(this, start, end, keyValuePairs));\n    _this9.special = \"Arglist\";\n    return _this9;\n  }\n\n  return ArglistParse;\n}(DictionaryParse);\n\nexports.ArglistParse = ArglistParse;\n\nvar VariableFlagParse =\n/*#__PURE__*/\nfunction (_Parse9) {\n  _inherits(VariableFlagParse, _Parse9);\n\n  function VariableFlagParse(start, end, variable) {\n    var _this10;\n\n    _classCallCheck(this, VariableFlagParse);\n\n    _this10 = _possibleConstructorReturn(this, _getPrototypeOf(VariableFlagParse).call(this, start, end));\n    _this10.variable = variable;\n    return _this10;\n  }\n\n  return VariableFlagParse;\n}(Parse);\n\nexports.VariableFlagParse = VariableFlagParse;\n\nvar ActionParse =\n/*#__PURE__*/\nfunction (_Parse10) {\n  _inherits(ActionParse, _Parse10);\n\n  function ActionParse(start, end, name, args, variable) {\n    var _this11;\n\n    _classCallCheck(this, ActionParse);\n\n    _this11 = _possibleConstructorReturn(this, _getPrototypeOf(ActionParse).call(this, start, end));\n    _this11.name = name;\n    _this11.args = args;\n    _this11.variable = variable;\n    return _this11;\n  } // Action[Argument,Argument...]\n\n\n  _createClass(ActionParse, [{\n    key: \"canBeText\",\n    value: function canBeText(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asText\",\n    value: function asText(cc) {\n      // Gets a text containing this action as a variable\n      var variable = this.asVariable(cc);\n      var text = new OutputData_1.Text();\n      text.add(variable);\n      return text;\n    }\n  }, {\n    key: \"canBeVariable\",\n    value: function canBeVariable(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asVariable\",\n    value: function asVariable(cc) {\n      // returns the Variable for this ActionParse\n      var action = this.asAction(cc); // adds the action\n\n      if (!action) {\n        throw this.error(cc, \"This action does not have an action.\");\n      }\n\n      return new OutputData_1.MagicVariable(action); // otherwise: add a Set Variable action\n      // throw new Error(`Actions of type ${action.info.id} cannot be converted to a variable.`);\n    }\n  }, {\n    key: \"canBeAction\",\n    value: function canBeAction(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asAction\",\n    value: function asAction(cc) {\n      var _wfAction;\n\n      // returns an Action for this ActionParse\n      if (!this.name.canBeString(cc)) {\n        throw this.name.error(cc, \"This action must contain a string name with no variables.\");\n      }\n\n      var actionName = this.name.asString(cc).toLowerCase();\n      var wfAction;\n      var controlFlowData;\n\n      if (actionName === \"flow\" || actionName === \"otherwise\" || actionName === \"else\" || actionName === \"case\") {\n        // flow/case/otherwise action\n        controlFlowData = cc.nextControlFlow();\n\n        if (!controlFlowData) {\n          throw this.name.error(cc, \"There are no open block actions. Make you have a block action such as `if` or `chooseFromMenu` and that you don't have any extra ends.\");\n        }\n\n        wfAction = controlFlowData[controlFlowData.length - 1].wfaction;\n      } else if (actionName === \"end\") {\n        controlFlowData = cc.endControlFlow();\n\n        if (!controlFlowData) {\n          throw this.name.error(cc, \"There are no open block actions. Make you have a block action such as `if` or `chooseFromMenu` and that you don't have any extra ends.\");\n        }\n\n        for (var i = controlFlowData.length - 1; i > 0; i--) {\n          var d = controlFlowData[i];\n          cc.add(HelpfulActions_2.endIf({\n            start: this.start,\n            end: this.end\n          }, d.uuid));\n        }\n\n        controlFlowData = [controlFlowData[0]];\n        wfAction = controlFlowData[0].wfaction;\n      } else if (actionName.startsWith(\"@\")) {\n        var preprocessorAction = cc.getParserAction(actionName.toLowerCase());\n\n        if (preprocessorAction) {\n          preprocessorAction.call.apply(preprocessorAction, [this, cc].concat(_toConsumableArray(this.args)));\n        } else {\n          throw this.name.error(cc, \"There is no converter action with the name \".concat(actionName, \".\"));\n        }\n\n        return;\n      } else {\n        wfAction = ActionData_1.getActionFromName(actionName);\n\n        if (!wfAction) {\n          throw this.name.error(cc, \"This action could not be found. Check the documentation for a list of actions.\");\n        }\n      }\n\n      if (!wfAction) {\n        throw this.name.error(cc, \"The action named \".concat(actionName.toLowerCase(), \" could not be found.\"));\n      }\n\n      var action = (_wfAction = wfAction).build.apply(_wfAction, [cc, this, controlFlowData ? controlFlowData[controlFlowData.length - 1] : undefined].concat(_toConsumableArray(this.args))); // WFAction adds it to cc for us, no need to do it ourselves.\n      // now add any required set variable actions\n\n\n      if (this.variable) {\n        if (!this.variable.canBeNameType(cc)) {\n          throw this.variable.error(cc, \"To set an output variable, the output variable must be a variable.\");\n        }\n\n        var _this$variable$asName = this.variable.asNameType(cc),\n            name = _this$variable$asName.name,\n            type = _this$variable$asName.type; // TODO not this\n\n\n        if (type === \"v\") {\n          cc.add(HelpfulActions_1.setVariable(this.variable, name));\n          cc.setNamedVariable(name);\n        } else if (type === \"mv\") {\n          action.magicvarname = name;\n          cc.setMagicVariable(name, action);\n        }\n      }\n\n      return action;\n    }\n  }]);\n\n  return ActionParse;\n}(Parse);\n\nexports.ActionParse = ActionParse;\n\nvar VariableParse =\n/*#__PURE__*/\nfunction (_Parse11) {\n  _inherits(VariableParse, _Parse11);\n\n  function VariableParse(start, end, type, name, forkey, options) {\n    var _this12;\n\n    _classCallCheck(this, VariableParse);\n\n    _this12 = _possibleConstructorReturn(this, _getPrototypeOf(VariableParse).call(this, start, end));\n    _this12.type = type;\n    _this12.name = name;\n    _this12.forkey = forkey;\n    _this12.options = options;\n    return _this12;\n  }\n\n  _createClass(VariableParse, [{\n    key: \"canBeStringVariable\",\n    value: function canBeStringVariable(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asStringVariable\",\n    value: function asStringVariable(cc) {\n      if (!this.name.canBeString(cc)) {\n        throw this.name.error(cc, \"This variable must have a string name with no variables.\");\n      }\n\n      if (!this.type.canBeString(cc)) {\n        throw this.type.error(cc, \"This variable must have a string type with no variables.\");\n      }\n\n      var name = this.name.asString(cc);\n      var type = this.type.asString(cc);\n\n      if (type !== \"v\") {\n        throw this.type.error(cc, \"This variable must be a v:named variable.\");\n      }\n\n      return name;\n    }\n  }, {\n    key: \"canBeNameType\",\n    value: function canBeNameType(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asNameType\",\n    value: function asNameType(cc) {\n      if (!this.name.canBeString(cc)) {\n        throw this.name.error(cc, \"This variable must have a string name with no variables.\");\n      }\n\n      if (!this.type.canBeString(cc)) {\n        throw this.type.error(cc, \"This variable must have a string type with no variables.\");\n      }\n\n      var name = this.name.asString(cc);\n      var type = this.type.asString(cc);\n\n      if (type !== \"v\" && type !== \"mv\") {\n        throw this.type.error(cc, \"This variable must be either a v: named variable or a mv: magic variable.\");\n      }\n\n      return {\n        name: name,\n        type: type\n      };\n    }\n  }, {\n    key: \"canBeText\",\n    value: function canBeText(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asText\",\n    value: function asText(cc) {\n      var text = new OutputData_1.Text();\n      text.add(this.asVariable(cc));\n      return text;\n    }\n  }, {\n    key: \"canBeVariable\",\n    value: function canBeVariable(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asVariable\",\n    value: function asVariable(cc) {\n      //Converts this v:variable to a variable\n      var variable;\n\n      if (!this.name.canBeString(cc)) {\n        throw this.name.error(cc, \"This variable must have a string name with no variables.\");\n      }\n\n      if (!this.type.canBeString(cc)) {\n        throw this.type.error(cc, \"This variable must have a string type with no variables.\");\n      }\n\n      var name = this.name.asString(cc);\n      var type = this.type.asString(cc);\n      var aggrandizements;\n\n      if (this.options) {\n        if (!this.options.canBeRawKeyedDictionary(cc)) {\n          throw this.options.error(cc, \"The aggrandizements for this variable must be a dictionary with no variables in keys.\");\n        }\n\n        aggrandizements = this.options.asRawKeyedDictionary(cc); // should be asRawKeyedDictionary and then use asstirng inside\n      } else {\n        aggrandizements = {};\n      }\n\n      if (type === \"v\") {\n        // named variable\n        var vardata = cc.getNamedVariable(name);\n\n        if (name.startsWith(\"Repeat Index\") || name.startsWith(\"Repeat Item\")) {\n          vardata = true;\n        }\n\n        if (!vardata) {\n          this.warn(cc, \"The variable `\".concat(type, \":\").concat(name, \"` has not been defined yet. Define it with a `setVariable` action.\"));\n        }\n\n        variable = new OutputData_1.NamedVariable(name);\n      } else if (type === \"mv\") {\n        // magic variable\n        var _vardata = cc.getMagicVariable(name);\n\n        if (!_vardata) {\n          this.warn(cc, \"The magic variable `\".concat(type, \":\").concat(name, \"` has not been defined yet. Define it by putting an arrow on an action, for example `myaction -> \").concat(type, \":\").concat(name, \"`\"));\n        }\n\n        var mvact = _vardata ? [_vardata.action] : [name, uuidv4()];\n        variable = _construct(OutputData_1.MagicVariable, mvact);\n      } else if (type === \"s\") {\n        // special variable\n        var attachtype = {\n          clipboard: \"Clipboard\",\n          askwhenrun: \"Ask\",\n          currentdate: \"CurrentDate\",\n          shortcutinput: \"ExtensionInput\",\n          actioninput: \"Input\"\n        };\n        var attachvalue = attachtype[name.toLowerCase()];\n\n        if (!attachvalue) {\n          throw this.name.error(cc, \"This special variable does not exist. Valid special variables are \".concat(Object.keys(attachtype)));\n        }\n\n        variable = new OutputData_1.Attachment(attachvalue);\n      } else {\n        throw this.type.error(cc, \"Variables must be either v: named variables, mv: magic variables, or s: special variables.\");\n      }\n\n      if (this.forkey) {\n        variable.aggrandizements.setCoercionType(\"dictionary\");\n\n        if (!this.forkey.canBeString(cc)) {\n          throw this.forkey.error(cc, \"The forkey section of this variable must be a string with no variables.\");\n        }\n\n        variable.aggrandizements.setForKey(this.forkey.asString(cc));\n      }\n\n      [\"as\", \"coerce\", \"key\", \"forkey\", \"get\", \"property\"].forEach(function (key) {\n        var valueA = aggrandizements[key];\n\n        if (!valueA) {\n          return;\n        } // skip\n\n\n        if (!valueA.canBeString(cc)) {\n          throw valueA.error(cc, \"Aggrandizements dictionary values must be strings\");\n        }\n\n        var value = valueA.asString(cc);\n        var shortKey = key.toLowerCase().replace(/[^a-z]/g, \"\");\n\n        if (shortKey === \"key\" || shortKey === \"forkey\") {\n          var result = variable.aggrandizements.setForKey(value);\n\n          if (typeof result === \"string\") {\n            throw valueA.error(cc, result);\n          }\n        } else if (shortKey === \"as\" || shortKey === \"coerce\") {\n          var _result = variable.aggrandizements.setCoercionType(value);\n\n          if (typeof _result === \"string\") {\n            throw valueA.error(cc, _result);\n          }\n        } else if (shortKey === \"get\" || shortKey === \"property\") {\n          var _result2 = variable.aggrandizements.setProperty(value);\n\n          if (typeof _result2 === \"string\") {\n            throw valueA.error(cc, _result2);\n          }\n        } else {\n          // it would be better to throw at the key but asRawKyeedDictionary doesn't allow that\n          // throwing at the value has strange problems with @; parser variables where it throws in the wrong place\n          throw valueA.error(cc, \"The aggrandizement \".concat(key.toLowerCase(), \" has not been implemented yet or is invalid. Valid are `key`, `as`, or `get`]\"));\n        }\n      });\n      return variable;\n    }\n  }, {\n    key: \"canBeAction\",\n    value: function canBeAction(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asAction\",\n    value: function asAction(cc) {\n      var action = HelpfulActions_1.getVariable(this, this.asVariable(cc));\n      cc.add(action);\n      return action;\n    }\n  }]);\n\n  return VariableParse;\n}(Parse);\n\nexports.VariableParse = VariableParse;\n\nvar ActionsParse =\n/*#__PURE__*/\nfunction (_Parse12) {\n  _inherits(ActionsParse, _Parse12);\n\n  function ActionsParse(start, end, actions) {\n    var _this13;\n\n    _classCallCheck(this, ActionsParse);\n\n    _this13 = _possibleConstructorReturn(this, _getPrototypeOf(ActionsParse).call(this, start, end));\n    _this13.actions = actions;\n    return _this13;\n  }\n\n  _createClass(ActionsParse, [{\n    key: \"canBeText\",\n    value: function canBeText(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asText\",\n    value: function asText(cc) {\n      var variable = this.asVariable(cc);\n      var text = new OutputData_1.Text();\n      text.add(variable);\n      return text;\n    }\n  }, {\n    key: \"canBeVariable\",\n    value: function canBeVariable(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asVariable\",\n    value: function asVariable(cc) {\n      var action = this.asAction(cc);\n\n      if (!action) {\n        throw this.error(cc, \"There are no actions to make a variable from.\");\n      }\n\n      return new OutputData_1.MagicVariable(action);\n    }\n  }, {\n    key: \"canBeAction\",\n    value: function canBeAction(_cc) {\n      return true;\n    }\n  }, {\n    key: \"asAction\",\n    value: function asAction(cc) {\n      var lastAction;\n      this.actions.forEach(function (action) {\n        if (!action.canBeAction(cc)) {\n          throw action.error(cc, \"This value must be an action.\");\n        }\n\n        lastAction = action.asAction(cc);\n      });\n      return lastAction;\n    }\n  }, {\n    key: \"asShortcut\",\n    value: function asShortcut(arg0, options) {\n      var cc;\n\n      if (arg0 instanceof Converter_1.ConvertingContext) {\n        cc = arg0;\n      } else {\n        cc = new Converter_1.ConvertingContext();\n        var converterActions = arg0;\n\n        if (converterActions) {\n          Object.keys(converterActions).forEach(function (key) {\n            cc.setParserAction(key, converterActions[key]);\n          });\n        }\n      }\n\n      cc.useWarnings = options.useWarnings;\n      this.asAction(cc);\n\n      if (cc.controlFlowStack.length !== 0) {\n        throw this.error(cc, \"There are \".concat(cc.controlFlowStack.length, \" unended block actions. Check to make sure that every block (if/repeat/choose from menu) has an end.\"));\n      }\n\n      return cc.shortcut;\n    }\n  }]);\n\n  return ActionsParse;\n}(Parse);\n\nexports.ActionsParse = ActionsParse; // Text::asString\n// Text::build","map":null,"metadata":{},"sourceType":"script"}
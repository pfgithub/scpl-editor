{"ast":null,"code":"'use strict'; // adapted from http://code.google.com/p/plist/source/browse/trunk/src/com/dd/plist/BinaryPropertyListParser.java\n\nvar fs = require('fs');\n\nvar bigInt = require(\"big-integer\");\n\nvar debug = false;\nexports.maxObjectSize = 100 * 1000 * 1000; // 100Meg\n\nexports.maxObjectCount = 32768; // EPOCH = new SimpleDateFormat(\"yyyy MM dd zzz\").parse(\"2001 01 01 GMT\").getTime();\n// ...but that's annoying in a static initializer because it can throw exceptions, ick.\n// So we just hardcode the correct value.\n\nvar EPOCH = 978307200000; // UID object definition\n\nvar UID = exports.UID = function (id) {\n  this.UID = id;\n};\n\nvar parseFile = exports.parseFile = function (fileNameOrBuffer, callback) {\n  function tryParseBuffer(buffer) {\n    var err = null;\n    var result;\n\n    try {\n      result = parseBuffer(buffer);\n    } catch (ex) {\n      err = ex;\n    }\n\n    callback(err, result);\n  }\n\n  if (Buffer.isBuffer(fileNameOrBuffer)) {\n    return tryParseBuffer(fileNameOrBuffer);\n  } else {\n    fs.readFile(fileNameOrBuffer, function (err, data) {\n      if (err) {\n        return callback(err);\n      }\n\n      tryParseBuffer(data);\n    });\n  }\n};\n\nvar parseBuffer = exports.parseBuffer = function (buffer) {\n  var result = {}; // check header\n\n  var header = buffer.slice(0, 'bplist'.length).toString('utf8');\n\n  if (header !== 'bplist') {\n    throw new Error(\"Invalid binary plist. Expected 'bplist' at offset 0.\");\n  } // Handle trailer, last 32 bytes of the file\n\n\n  var trailer = buffer.slice(buffer.length - 32, buffer.length); // 6 null bytes (index 0 to 5)\n\n  var offsetSize = trailer.readUInt8(6);\n\n  if (debug) {\n    console.log(\"offsetSize: \" + offsetSize);\n  }\n\n  var objectRefSize = trailer.readUInt8(7);\n\n  if (debug) {\n    console.log(\"objectRefSize: \" + objectRefSize);\n  }\n\n  var numObjects = readUInt64BE(trailer, 8);\n\n  if (debug) {\n    console.log(\"numObjects: \" + numObjects);\n  }\n\n  var topObject = readUInt64BE(trailer, 16);\n\n  if (debug) {\n    console.log(\"topObject: \" + topObject);\n  }\n\n  var offsetTableOffset = readUInt64BE(trailer, 24);\n\n  if (debug) {\n    console.log(\"offsetTableOffset: \" + offsetTableOffset);\n  }\n\n  if (numObjects > exports.maxObjectCount) {\n    throw new Error(\"maxObjectCount exceeded\");\n  } // Handle offset table\n\n\n  var offsetTable = [];\n\n  for (var i = 0; i < numObjects; i++) {\n    var offsetBytes = buffer.slice(offsetTableOffset + i * offsetSize, offsetTableOffset + (i + 1) * offsetSize);\n    offsetTable[i] = readUInt(offsetBytes, 0);\n\n    if (debug) {\n      console.log(\"Offset for Object #\" + i + \" is \" + offsetTable[i] + \" [\" + offsetTable[i].toString(16) + \"]\");\n    }\n  } // Parses an object inside the currently parsed binary property list.\n  // For the format specification check\n  // <a href=\"http://www.opensource.apple.com/source/CF/CF-635/CFBinaryPList.c\">\n  // Apple's binary property list parser implementation</a>.\n\n\n  function parseObject(tableOffset) {\n    var offset = offsetTable[tableOffset];\n    var type = buffer[offset];\n    var objType = (type & 0xF0) >> 4; //First  4 bits\n\n    var objInfo = type & 0x0F; //Second 4 bits\n\n    switch (objType) {\n      case 0x0:\n        return parseSimple();\n\n      case 0x1:\n        return parseInteger();\n\n      case 0x8:\n        return parseUID();\n\n      case 0x2:\n        return parseReal();\n\n      case 0x3:\n        return parseDate();\n\n      case 0x4:\n        return parseData();\n\n      case 0x5:\n        // ASCII\n        return parsePlistString();\n\n      case 0x6:\n        // UTF-16\n        return parsePlistString(true);\n\n      case 0xA:\n        return parseArray();\n\n      case 0xD:\n        return parseDictionary();\n\n      default:\n        throw new Error(\"Unhandled type 0x\" + objType.toString(16));\n    }\n\n    function parseSimple() {\n      //Simple\n      switch (objInfo) {\n        case 0x0:\n          // null\n          return null;\n\n        case 0x8:\n          // false\n          return false;\n\n        case 0x9:\n          // true\n          return true;\n\n        case 0xF:\n          // filler byte\n          return null;\n\n        default:\n          throw new Error(\"Unhandled simple type 0x\" + objType.toString(16));\n      }\n    }\n\n    function bufferToHexString(buffer) {\n      var str = '';\n      var i;\n\n      for (i = 0; i < buffer.length; i++) {\n        if (buffer[i] != 0x00) {\n          break;\n        }\n      }\n\n      for (; i < buffer.length; i++) {\n        var part = '00' + buffer[i].toString(16);\n        str += part.substr(part.length - 2);\n      }\n\n      return str;\n    }\n\n    function parseInteger() {\n      var length = Math.pow(2, objInfo);\n\n      if (length > 4) {\n        var data = buffer.slice(offset + 1, offset + 1 + length);\n        var str = bufferToHexString(data);\n        return bigInt(str, 16);\n      }\n\n      if (length < exports.maxObjectSize) {\n        return readUInt(buffer.slice(offset + 1, offset + 1 + length));\n      } else {\n        throw new Error(\"To little heap space available! Wanted to read \" + length + \" bytes, but only \" + exports.maxObjectSize + \" are available.\");\n      }\n    }\n\n    function parseUID() {\n      var length = objInfo + 1;\n\n      if (length < exports.maxObjectSize) {\n        return new UID(readUInt(buffer.slice(offset + 1, offset + 1 + length)));\n      } else {\n        throw new Error(\"To little heap space available! Wanted to read \" + length + \" bytes, but only \" + exports.maxObjectSize + \" are available.\");\n      }\n    }\n\n    function parseReal() {\n      var length = Math.pow(2, objInfo);\n\n      if (length < exports.maxObjectSize) {\n        var realBuffer = buffer.slice(offset + 1, offset + 1 + length);\n\n        if (length === 4) {\n          return realBuffer.readFloatBE(0);\n        } else if (length === 8) {\n          return realBuffer.readDoubleBE(0);\n        }\n      } else {\n        throw new Error(\"To little heap space available! Wanted to read \" + length + \" bytes, but only \" + exports.maxObjectSize + \" are available.\");\n      }\n    }\n\n    function parseDate() {\n      if (objInfo != 0x3) {\n        console.error(\"Unknown date type :\" + objInfo + \". Parsing anyway...\");\n      }\n\n      var dateBuffer = buffer.slice(offset + 1, offset + 9);\n      return new Date(EPOCH + 1000 * dateBuffer.readDoubleBE(0));\n    }\n\n    function parseData() {\n      var dataoffset = 1;\n      var length = objInfo;\n\n      if (objInfo == 0xF) {\n        var int_type = buffer[offset + 1];\n        var intType = (int_type & 0xF0) / 0x10;\n\n        if (intType != 0x1) {\n          console.error(\"0x4: UNEXPECTED LENGTH-INT TYPE! \" + intType);\n        }\n\n        var intInfo = int_type & 0x0F;\n        var intLength = Math.pow(2, intInfo);\n        dataoffset = 2 + intLength;\n\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      }\n\n      if (length < exports.maxObjectSize) {\n        return buffer.slice(offset + dataoffset, offset + dataoffset + length);\n      } else {\n        throw new Error(\"To little heap space available! Wanted to read \" + length + \" bytes, but only \" + exports.maxObjectSize + \" are available.\");\n      }\n    }\n\n    function parsePlistString(isUtf16) {\n      isUtf16 = isUtf16 || 0;\n      var enc = \"utf8\";\n      var length = objInfo;\n      var stroffset = 1;\n\n      if (objInfo == 0xF) {\n        var int_type = buffer[offset + 1];\n        var intType = (int_type & 0xF0) / 0x10;\n\n        if (intType != 0x1) {\n          console.err(\"UNEXPECTED LENGTH-INT TYPE! \" + intType);\n        }\n\n        var intInfo = int_type & 0x0F;\n        var intLength = Math.pow(2, intInfo);\n        var stroffset = 2 + intLength;\n\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      } // length is String length -> to get byte length multiply by 2, as 1 character takes 2 bytes in UTF-16\n\n\n      length *= isUtf16 + 1;\n\n      if (length < exports.maxObjectSize) {\n        var plistString = new Buffer(buffer.slice(offset + stroffset, offset + stroffset + length));\n\n        if (isUtf16) {\n          plistString = swapBytes(plistString);\n          enc = \"ucs2\";\n        }\n\n        return plistString.toString(enc);\n      } else {\n        throw new Error(\"To little heap space available! Wanted to read \" + length + \" bytes, but only \" + exports.maxObjectSize + \" are available.\");\n      }\n    }\n\n    function parseArray() {\n      var length = objInfo;\n      var arrayoffset = 1;\n\n      if (objInfo == 0xF) {\n        var int_type = buffer[offset + 1];\n        var intType = (int_type & 0xF0) / 0x10;\n\n        if (intType != 0x1) {\n          console.error(\"0xa: UNEXPECTED LENGTH-INT TYPE! \" + intType);\n        }\n\n        var intInfo = int_type & 0x0F;\n        var intLength = Math.pow(2, intInfo);\n        arrayoffset = 2 + intLength;\n\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      }\n\n      if (length * objectRefSize > exports.maxObjectSize) {\n        throw new Error(\"To little heap space available!\");\n      }\n\n      var array = [];\n\n      for (var i = 0; i < length; i++) {\n        var objRef = readUInt(buffer.slice(offset + arrayoffset + i * objectRefSize, offset + arrayoffset + (i + 1) * objectRefSize));\n        array[i] = parseObject(objRef);\n      }\n\n      return array;\n    }\n\n    function parseDictionary() {\n      var length = objInfo;\n      var dictoffset = 1;\n\n      if (objInfo == 0xF) {\n        var int_type = buffer[offset + 1];\n        var intType = (int_type & 0xF0) / 0x10;\n\n        if (intType != 0x1) {\n          console.error(\"0xD: UNEXPECTED LENGTH-INT TYPE! \" + intType);\n        }\n\n        var intInfo = int_type & 0x0F;\n        var intLength = Math.pow(2, intInfo);\n        dictoffset = 2 + intLength;\n\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      }\n\n      if (length * 2 * objectRefSize > exports.maxObjectSize) {\n        throw new Error(\"To little heap space available!\");\n      }\n\n      if (debug) {\n        console.log(\"Parsing dictionary #\" + tableOffset);\n      }\n\n      var dict = {};\n\n      for (var i = 0; i < length; i++) {\n        var keyRef = readUInt(buffer.slice(offset + dictoffset + i * objectRefSize, offset + dictoffset + (i + 1) * objectRefSize));\n        var valRef = readUInt(buffer.slice(offset + dictoffset + length * objectRefSize + i * objectRefSize, offset + dictoffset + length * objectRefSize + (i + 1) * objectRefSize));\n        var key = parseObject(keyRef);\n        var val = parseObject(valRef);\n\n        if (debug) {\n          console.log(\"  DICT #\" + tableOffset + \": Mapped \" + key + \" to \" + val);\n        }\n\n        dict[key] = val;\n      }\n\n      return dict;\n    }\n  }\n\n  return [parseObject(topObject)];\n};\n\nfunction readUInt(buffer, start) {\n  start = start || 0;\n  var l = 0;\n\n  for (var i = start; i < buffer.length; i++) {\n    l <<= 8;\n    l |= buffer[i] & 0xFF;\n  }\n\n  return l;\n} // we're just going to toss the high order bits because javascript doesn't have 64-bit ints\n\n\nfunction readUInt64BE(buffer, start) {\n  var data = buffer.slice(start, start + 8);\n  return data.readUInt32BE(4, 8);\n}\n\nfunction swapBytes(buffer) {\n  var len = buffer.length;\n\n  for (var i = 0; i < len; i += 2) {\n    var a = buffer[i];\n    buffer[i] = buffer[i + 1];\n    buffer[i + 1] = a;\n  }\n\n  return buffer;\n}","map":null,"metadata":{},"sourceType":"script"}
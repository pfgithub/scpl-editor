{"ast":null,"code":"var stream = require(\"stream\"),\n    constants = require(\"./constants\"),\n    util = require(\"util\");\n\nvar ReadableStreamBuffer = module.exports = function (opts) {\n  var that = this;\n  stream.Stream.call(this);\n  opts = opts || {};\n  var frequency = opts.hasOwnProperty(\"frequency\") ? opts.frequency : constants.DEFAULT_FREQUENCY;\n  var chunkSize = opts.chunkSize || constants.DEFAULT_CHUNK_SIZE;\n  var initialSize = opts.initialSize || constants.DEFAULT_INITIAL_SIZE;\n  var incrementAmount = opts.incrementAmount || constants.DEFAULT_INCREMENT_AMOUNT;\n  var size = 0;\n  var buffer = new Buffer(initialSize);\n  var encoding = null;\n  this.readable = true;\n  this.writable = false;\n\n  var _sendData = function sendData() {\n    var amount = Math.min(chunkSize, size);\n\n    if (amount > 0) {\n      var chunk = null;\n\n      if (encoding) {\n        chunk = buffer.toString(encoding, 0, amount);\n      } else {\n        chunk = new Buffer(amount);\n        buffer.copy(chunk, 0, 0, amount);\n      }\n\n      that.emit(\"data\", chunk);\n      if (amount < buffer.length) buffer.copy(buffer, 0, amount, size);\n      size -= amount;\n    }\n\n    if (size === 0 && !that.readable) {\n      that.emit(\"end\");\n      that.emit(\"close\");\n\n      if (_sendData && _sendData.interval) {\n        clearInterval(_sendData.interval);\n        _sendData.interval = null;\n      }\n    }\n  };\n\n  this.size = function () {\n    return size;\n  };\n\n  this.maxSize = function () {\n    return buffer.length;\n  };\n\n  var increaseBufferIfNecessary = function increaseBufferIfNecessary(incomingDataSize) {\n    if (buffer.length - size < incomingDataSize) {\n      var factor = Math.ceil((incomingDataSize - (buffer.length - size)) / incrementAmount);\n      var newBuffer = new Buffer(buffer.length + incrementAmount * factor);\n      buffer.copy(newBuffer, 0, 0, size);\n      buffer = newBuffer;\n    }\n  };\n\n  this.put = function (data, encoding) {\n    if (!that.readable) return;\n    var wasEmpty = size === 0;\n\n    if (Buffer.isBuffer(data)) {\n      increaseBufferIfNecessary(data.length);\n      data.copy(buffer, size, 0);\n      size += data.length;\n    } else {\n      data = data + \"\";\n      var dataSizeInBytes = Buffer.byteLength(data);\n      increaseBufferIfNecessary(dataSizeInBytes);\n      buffer.write(data, size, encoding || \"utf8\");\n      size += dataSizeInBytes;\n    }\n\n    if (wasEmpty && size > 0) {\n      this.emit('readable');\n    }\n\n    if (!this.isPaused && !frequency) {\n      while (size > 0) {\n        _sendData();\n      }\n    }\n  };\n\n  this.pause = function () {\n    this.isPaused = true;\n\n    if (_sendData && _sendData.interval) {\n      clearInterval(_sendData.interval);\n      delete _sendData.interval;\n    }\n  };\n\n  this.resume = function () {\n    this.isPaused = false;\n\n    if (_sendData && !_sendData.interval && frequency > 0) {\n      _sendData.interval = setInterval(_sendData, frequency);\n    }\n  };\n\n  this.destroy = function () {\n    that.emit(\"end\");\n    if (_sendData.interval) clearInterval(_sendData.interval);\n    _sendData = null;\n    that.readable = false;\n    that.emit(\"close\");\n  };\n\n  this.destroySoon = function () {\n    that.readable = false;\n\n    if (!_sendData.interval) {\n      that.emit(\"end\");\n      that.emit(\"close\");\n    }\n  };\n\n  this.setEncoding = function (_encoding) {\n    encoding = _encoding;\n  };\n\n  this.resume();\n};\n\nutil.inherits(ReadableStreamBuffer, stream.Stream);","map":null,"metadata":{},"sourceType":"script"}
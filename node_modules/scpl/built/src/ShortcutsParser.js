"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ParserData_1 = require("./ParserData");
const ParserHelper_1 = require("./ParserHelper");
ParserHelper_1.o.identifier = ParserHelper_1.regex(/^[A-Za-z@_][A-Za-z0-9@_]*/).scb(([fullmatch], start, end) => new ParserData_1.IdentifierParse(start, end, fullmatch));
ParserHelper_1.o.newline = ParserHelper_1.p(ParserHelper_1.o.space, ParserHelper_1.plus(ParserHelper_1.p(ParserHelper_1.o.space, ParserHelper_1.or(ParserHelper_1.c `\n`, ParserHelper_1.c `;`))), ParserHelper_1.o.space).scb(_ => null);
ParserHelper_1.o.multilineComment = ParserHelper_1.or(ParserHelper_1.regex(/^--\[\[[\s\S]+?--\]\]/), // --[[ Lua style multiline comments --]]
ParserHelper_1.regex(/^\/\*[\s\S]+?\*\//) // /* CLike multiline comments*/
).scb(_ => null);
ParserHelper_1.o.eolComment = ParserHelper_1.or(ParserHelper_1.regex(/^\/\/.*/), // // CLike single line comments
ParserHelper_1.regex(/^--.*/), // -- Lua style single line comments
ParserHelper_1.regex(/^#.*/) // # Python style single line comments
); // or --
ParserHelper_1.o.spaceonly = ParserHelper_1.regex(/^[ ,\r\t]*/).scb(_ => null);
ParserHelper_1.o.space = ParserHelper_1.p(ParserHelper_1.o.spaceonly, ParserHelper_1.optional(ParserHelper_1.o.multilineComment), ParserHelper_1.o.spaceonly, ParserHelper_1.optional(ParserHelper_1.o.eolComment)).scb(_ => null);
ParserHelper_1.o.optionalNewline = ParserHelper_1.star(ParserHelper_1.or(ParserHelper_1.o.newline, ParserHelper_1.o.space)).scb(() => null);
const _ = ParserHelper_1.o.space;
const newline = ParserHelper_1.o.newline;
const _n = ParserHelper_1.o.optionalNewline;
ParserHelper_1.o.number = ParserHelper_1.regex(/^-?(?:[0-9]*\.[0-9]+|[0-9]+)/).scb(([fullmatch], start, end) => new ParserData_1.NumberParse(start, end, fullmatch));
ParserHelper_1.o.escape = ParserHelper_1.p(ParserHelper_1.c `\\`, ParserHelper_1.or(ParserHelper_1.o.parenthesis, ParserHelper_1.c `"`, ParserHelper_1.c `'`, ParserHelper_1.c `\`\`\``, ParserHelper_1.c `\``, ParserHelper_1.c `\\`, ParserHelper_1.c `”`, ParserHelper_1.c `n`.scb(_ => "\n"), ParserHelper_1.error(ParserHelper_1.regex(/.?/), v => `Did you mean \`\\\\\`? The character \`${v[0]}\` is not a valid escape sequence. See the docs page on string escapes for more info.`))).scb(([, val]) => val);
// o.tripleQuotedStringEscape = p(
// 	c`\\`,
// 	or(o.parenthesis, c`"`, c`'`, c`\`\`\``, c`\\`, c`”`, c`n`.scb(_ => "\n"))
// ).scb(([, val]) => val);
// \"
ParserHelper_1.o.char = ParserHelper_1.or(ParserHelper_1.o.escape, ParserHelper_1.regex(/^[^\\\n]+/).scb(data => data[0]));
ParserHelper_1.o.chars = ParserHelper_1.star(ParserHelper_1.o.char).scb((data, start, end) => new ParserData_1.CharsParse(start, end, data));
ParserHelper_1.o.dquotedStringChar = ParserHelper_1.or(ParserHelper_1.o.escape, ParserHelper_1.regex(/^[^"\\\n]+/).scb(data => data[0]));
ParserHelper_1.o.squotedStringChar = ParserHelper_1.or(ParserHelper_1.o.escape, ParserHelper_1.regex(/^[^'\\\n]+/).scb(data => data[0]));
ParserHelper_1.o.smartQuotedStringChar = ParserHelper_1.or(ParserHelper_1.o.escape, ParserHelper_1.regex(/^[^”\\\n]+/).scb(data => data[0]));
ParserHelper_1.o.backtickQuotedStringChar = ParserHelper_1.or(ParserHelper_1.o.escape, ParserHelper_1.regex(/^[^`\\]+/).scb(data => data[0]));
// o.triplequotedStringChar = or(
// 	o.tripleQuotedStringEscape, // \``` | ${varname}
// 	regex(/^[^`\\\n]+/).scb(data => data[0]),
// );
ParserHelper_1.o.dquotedString = ParserHelper_1.p(ParserHelper_1.c `"`, ParserHelper_1.star(ParserHelper_1.o.dquotedStringChar), ParserHelper_1.c `"`).scb(([, chars], start, end) => new ParserData_1.CharsParse(start, end, chars));
ParserHelper_1.o.squotedString = ParserHelper_1.p(ParserHelper_1.c `'`, ParserHelper_1.star(ParserHelper_1.o.squotedStringChar), ParserHelper_1.c `'`).scb(([, chars], start, end) => new ParserData_1.CharsParse(start, end, chars));
ParserHelper_1.o.smartQuotedString = ParserHelper_1.p(ParserHelper_1.c `“`, ParserHelper_1.star(ParserHelper_1.o.smartQuotedStringChar), ParserHelper_1.c `”`).scb(([, chars], start, end) => new ParserData_1.CharsParse(start, end, chars));
ParserHelper_1.o.backtickQuotedString = ParserHelper_1.p(ParserHelper_1.c `\``, ParserHelper_1.star(ParserHelper_1.o.backtickQuotedStringChar), ParserHelper_1.c `\``).scb(([, chars], start, end) => new ParserData_1.CharsParse(start, end, chars));
// o.triplequotedString = p(c`\`\`\``, star(o.triplequotedStringChar), c`\`\`\``).scb(
// 	([, chars], start, end) => new CharsParse(start, end, chars)
// );
// o.tripleQuotedStringChar = or(regex(/^[^`]+/));
//
// o.triplequotedString = p(
// 	c`\`\`\``,
// 	newline,
// 	star(o.tripleQuotedStringChar),
// 	c`\`\`\``
// );
ParserHelper_1.o.string = ParserHelper_1.or(ParserHelper_1.o.dquotedString, ParserHelper_1.o.squotedString, ParserHelper_1.o.smartQuotedString, ParserHelper_1.o.backtickQuotedString);
ParserHelper_1.o.barlistitem = ParserHelper_1.p(newline, _, ParserHelper_1.c `|`, _, ParserHelper_1.o.chars).scb(([, , , , dat]) => dat);
ParserHelper_1.o.barlist = ParserHelper_1.plus(ParserHelper_1.o.barlistitem).scb((items, start, end) => new ParserData_1.BarlistParse(start, end, items));
ParserHelper_1.o.extendedarg = ParserHelper_1.p(newline, _, ParserHelper_1.c `>`, _, ParserHelper_1.o.argument).scb(([, , , , arg]) => arg);
ParserHelper_1.o.argflagarrow = ParserHelper_1.or(ParserHelper_1.c `->`, ParserHelper_1.c `=>`).scb(_ => null);
ParserHelper_1.o.argflag = ParserHelper_1.p(ParserHelper_1.o.argflagarrow, _, ParserHelper_1.o.variable).scb(([, , variable], start, end) => new ParserData_1.VariableFlagParse(start, end, variable));
ParserHelper_1.o.namedargument = ParserHelper_1.p(ParserHelper_1.o.identifier, _, ParserHelper_1.c `=`, _, ParserHelper_1.o.value).scb(([key, , , , value], start, end) => new ParserData_1.ArglistParse(start, end, [{ key: key, value: value }]));
ParserHelper_1.o.errorparse = ParserHelper_1.regex(/^\?\?(.+?)\?\?/).scb(([message], start, end) => new ParserData_1.ErrorParse(start, end, message));
ParserHelper_1.o.argument = ParserHelper_1.or(ParserHelper_1.o.arglist, // arglist should be removed.
ParserHelper_1.o.namedargument, ParserHelper_1.o.value, ParserHelper_1.o.inputarg, ParserHelper_1.o.barlist, ParserHelper_1.o.argflag, ParserHelper_1.o.arglistparenthesis, ParserHelper_1.o.extendedarg, ParserHelper_1.o.errorparse
// if something reaches the end of this without matching anything we can probably error right here rather than going all the way back up to an actionsparse
);
ParserHelper_1.o.macroBlock = ParserHelper_1.p(ParserHelper_1.c `@{`, ParserHelper_1.o.actions, ParserHelper_1.c `}`).scb(([, actions]) => actions);
ParserHelper_1.o.action = ParserHelper_1.or(ParserHelper_1.o.flaggedaction, ParserHelper_1.o.variable, ParserHelper_1.o.onlyaction);
ParserHelper_1.o.arglistparenthesis = ParserHelper_1.p(ParserHelper_1.c `(`, ParserHelper_1.star(ParserHelper_1.p(_n, ParserHelper_1.o.keyvaluepair, _n).scb(([, v]) => v)), ParserHelper_1.c `)`).scb(([, kvps], start, end) => new ParserData_1.ArglistParse(start, end, kvps)); // (a:b, a=b)
ParserHelper_1.o.arglist = ParserHelper_1.p(ParserHelper_1.c `a{`, ParserHelper_1.star(ParserHelper_1.p(_, ParserHelper_1.o.keyvaluepair, _).scb(([, v]) => v)), ParserHelper_1.c `}`).scb(([, kvps], start, end) => new ParserData_1.ArglistParse(start, end, kvps));
ParserHelper_1.o.inputarg = ParserHelper_1.p(ParserHelper_1.c `^`, ParserHelper_1.or(ParserHelper_1.o.parenthesis, ParserHelper_1.o.variable)).scb(([, paren]) => {
    paren.special = "InputArg";
    return paren;
});
ParserHelper_1.o.flaggedaction = ParserHelper_1.p(ParserHelper_1.o.variable, _, ParserHelper_1.c `=`, _, ParserHelper_1.o.onlyaction).scb(([variable, , , , action], start, end) => {
    if (action.variable) {
        throw new ParserData_1.PositionedError("Actions cannot output to multiple variables", start, end);
    }
    action.variable = variable;
    return action;
});
ParserHelper_1.o.onlyaction = ParserHelper_1.p(ParserHelper_1.o.identifier, _, ParserHelper_1.o.args).scb(([actionIdentifier, _, args], start, end) => {
    const flags = [];
    args = args.filter((arg) => arg && arg instanceof ParserData_1.VariableFlagParse
        ? flags.push(arg) && false
        : true);
    if (flags.length > 1) {
        throw new ParserData_1.PositionedError("Actions cannot output to multiple variables", start, end);
    }
    const res = {
        type: "action",
        action: actionIdentifier,
        args: args
    };
    if (flags[0]) {
        res.variable = flags[0].variable;
    }
    // @ts-ignore
    const actionParse = new ParserData_1.ActionParse(start, end, res.action, res.args, res.variable);
    return actionParse;
});
ParserHelper_1.o.args = ParserHelper_1.star(ParserHelper_1.p(ParserHelper_1.o.argument, _).scb(data => data[0]));
ParserHelper_1.o.value = ParserHelper_1.or(ParserHelper_1.o.variable, ParserHelper_1.o.string, ParserHelper_1.o.number, ParserHelper_1.o.macroBlock, ParserHelper_1.o.identifier, ParserHelper_1.o.parenthesis, ParserHelper_1.o.dictionary, ParserHelper_1.o.list, ParserHelper_1.o.filter);
ParserHelper_1.o.dictionary = ParserHelper_1.p(ParserHelper_1.c `{`, _n, 
//  [ [  ,         [  [   ,     id       ,     ]] , item         ]]
ParserHelper_1.star(ParserHelper_1.p(_n, ParserHelper_1.optional(ParserHelper_1.p(ParserHelper_1.c `<`, ParserHelper_1.o.identifier, ParserHelper_1.c `>`).scb(([, m]) => m)).scb(([a]) => a), ParserHelper_1.o.keyvaluepair)).scb(items => {
    return items.map((item) => {
        const [, type, kvp] = item;
        kvp.type = type;
        return kvp;
    });
}), _n, ParserHelper_1.c `}`).scb(([, , kvps], start, end) => new ParserData_1.DictionaryParse(start, end, kvps));
ParserHelper_1.o.list = ParserHelper_1.p(ParserHelper_1.c `[`, _n, ParserHelper_1.star(ParserHelper_1.p(ParserHelper_1.o.value, _n).scb(([value]) => value)), ParserHelper_1.c `]`).scb(([, , values], start, end) => new ParserData_1.ListParse(start, end, values));
ParserHelper_1.o.filter = ParserHelper_1.or(ParserHelper_1.o.filterand, ParserHelper_1.o.filteror);
ParserHelper_1.o.filterand = ParserHelper_1.p(ParserHelper_1.c `:filter{`, _n, ParserHelper_1.star(ParserHelper_1.p(_n, ParserHelper_1.o.filteritem, _n, ParserHelper_1.or(ParserHelper_1.c `&`, ParserHelper_1.c `:and:`), _n).scb(([, item]) => item)), ParserHelper_1.o.filteritem, _n, ParserHelper_1.c `}`).scb(([, , filterItems, lastFilterItem], start, end) => new ParserData_1.FilterParse(start, end, "and", [...filterItems, lastFilterItem]));
ParserHelper_1.o.filteror = ParserHelper_1.p(ParserHelper_1.c `:filter{`, _n, ParserHelper_1.star(ParserHelper_1.p(_n, ParserHelper_1.o.filteritem, _n, ParserHelper_1.or(ParserHelper_1.c `|`, ParserHelper_1.c `:or:`), _n).scb(([, item]) => item)), ParserHelper_1.o.filteritem, _n, ParserHelper_1.c `}`).scb(([, , filterItems, lastFilterItem], start, end) => new ParserData_1.FilterParse(start, end, "or", [...filterItems, lastFilterItem]));
// :filter{name is "hello there" :or: name "starts with" "test"}
ParserHelper_1.o.filteritem = ParserHelper_1.or(ParserHelper_1.p(ParserHelper_1.o.value, _n, ParserHelper_1.o.value, _n, ParserHelper_1.o.value, _n, ParserHelper_1.o.value).scb(([property, , comparator, , value, , units], start, end) => new ParserData_1.FilterItemParse(start, end, property, comparator, value, units)), ParserHelper_1.p(ParserHelper_1.o.value, _n, ParserHelper_1.o.value, _n, ParserHelper_1.o.value).scb(([property, , comparator, , value], start, end) => new ParserData_1.FilterItemParse(start, end, property, comparator, value)));
ParserHelper_1.o.keyvaluepair = ParserHelper_1.p(_n, ParserHelper_1.or(ParserHelper_1.o.string, ParserHelper_1.o.identifier), _n, ParserHelper_1.or(ParserHelper_1.c `=`, ParserHelper_1.c `:`), _n, ParserHelper_1.o.value, // ...
_n).scb(([, key, , , , value]) => ({ key: key, value: value }));
ParserHelper_1.o.variable = ParserHelper_1.p(ParserHelper_1.o.identifier, ParserHelper_1.c `:`, ParserHelper_1.or(ParserHelper_1.o.identifier, ParserHelper_1.o.string, ParserHelper_1.o.errorparse), ParserHelper_1.optional(ParserHelper_1.p(ParserHelper_1.or(ParserHelper_1.c `:`, ParserHelper_1.c `.`), ParserHelper_1.or(ParserHelper_1.o.identifier, ParserHelper_1.o.string)).scb(([, val]) => val)).scb(([val]) => val), ParserHelper_1.optional(ParserHelper_1.o.dictionary).scb(([dict]) => dict)).scb(([type, , name, forkey, options], start, end) => {
    if (type.value === "@") {
        return new ParserData_1.ConvertVariableParse(start, end, name, options);
    }
    return new ParserData_1.VariableParse(start, end, type, name, forkey, options);
});
ParserHelper_1.o.parenthesis = ParserHelper_1.p(ParserHelper_1.c `(`, _n, ParserHelper_1.or(ParserHelper_1.o.action, ParserHelper_1.o.variable), _n, ParserHelper_1.c `)`).scb(([, , actionOrVariable]) => actionOrVariable);
ParserHelper_1.o.actions = ParserHelper_1.p(_n, ParserHelper_1.star(ParserHelper_1.p(_n, ParserHelper_1.o.action, newline).scb(([, action]) => action)), ParserHelper_1.optional(ParserHelper_1.p(_n, ParserHelper_1.o.action).scb(([, action]) => action)), _n).scb(([, v, e], start, end) => new ParserData_1.ActionsParse(start, end, e ? [...v, ...e] : v));
exports.default = ParserHelper_1.o.actions.getProd();

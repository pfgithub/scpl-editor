"use strict";
// accepts AsAble[] and array of arg names in positions
// -> cb(argname, argvalue)
Object.defineProperty(exports, "__esModule", { value: true });
const ActionData_1 = require("./ActionData");
function simpleParse(cc, names, args) {
    const res = {};
    ArgParser(names.map(n => ({ name: n, data: undefined })), (arg, value) => {
        res[arg.name] = value;
    }, value => {
        throw value.error(cc, "InputArg is not allowed for this function");
    }, (arg, value) => {
        return true;
    }, { args, cc });
    return res;
}
exports.simpleParse = simpleParse;
function ArgParser(argnames, cb, inputarg, shouldEnable, data) {
    const cc = data.cc;
    let parami = 0;
    const setArgs = [];
    data.args.forEach(param => {
        if (param.special === "InputArg") {
            if (!param.canBeAction(cc)) {
                throw param.error(cc, "InputArg fields only accept actions and variables.");
            }
            inputarg(param);
            return;
        }
        if (param.special === "Arglist") {
            if (!param.canBeRawKeyedDictionary(cc)) {
                throw param.error(cc, "ArgList fields only accept dictionaries.");
            }
            const dictionary = param.asRawKeyedDictionary(cc);
            Object.keys(dictionary).forEach(key_ => {
                const key = ActionData_1.genShortName(key_);
                const value = dictionary[key_];
                const foundData = argnames.find(an => an.name === key);
                if (!foundData) {
                    throw value.error(cc, `No argument exists with the name \`${key}\`. Arguments are: ${argnames
                        .map(an => an.name)
                        .join(`, `)}`);
                }
                if (setArgs.indexOf(key) > -1) {
                    throw value.error(cc, `The argument \`${key}\` has already been set for this function.`);
                }
                setArgs.push(key);
                cb(foundData, value);
            });
            return;
        }
        let paramname;
        while (!paramname) {
            paramname = argnames[parami];
            if (!paramname) {
                throw param.error(cc, `This action does not have any more arguments. Arguments are: ${argnames
                    .map(an => an.name)
                    .join(`, `)}`);
            }
            if (setArgs.indexOf(paramname.name) > -1) {
                paramname = undefined;
                parami++;
                continue;
            }
            setArgs.push(paramname.name);
            if (!shouldEnable(paramname, param)) {
                paramname = undefined;
                parami++;
                continue;
            }
            parami++;
        }
        cb(paramname, param);
    });
}
exports.ArgParser = ArgParser;

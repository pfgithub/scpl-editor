{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar HelpfulActions_1 = require(\"./HelpfulActions\");\n\nvar ActionData_1 = require(\"./ActionData\");\n\nvar ShortcutMeta_1 = require(\"./Data/ShortcutMeta\");\n\nvar ArgParser_1 = require(\"./ArgParser\");\n\nfunction glyphAction(cc, iconName) {\n  if (!iconName) {\n    throw this.error(cc, \"Please provide a glyph name.\");\n  }\n\n  if (!iconName.canBeString(cc)) {\n    throw this.error(cc, \"Glyph name must be able to be a string\");\n  }\n\n  var glyph = ShortcutMeta_1.glyphs[iconName.asString(cc).toLowerCase().replace(/[^a-z]/g, \"\")];\n\n  if (!glyph) {\n    throw this.error(cc, \"Invalid glyph name. Must be one of: \".concat(Object.keys(ShortcutMeta_1.glyphs)));\n  }\n\n  cc.shortcut.glyph = glyph;\n}\n\nvar preprocessorActions = {\n  \"@set\": function set(cc) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var pres = ArgParser_1.simpleParse(cc, [\"name\", \"value\"], args);\n    var namea = pres.name;\n    var value = pres.value;\n\n    if (!namea || !value) {\n      throw this.error(cc, \"@set must have a name argument and a value argument.\");\n    } // sets a variable with name name to value value\n\n\n    var name;\n\n    if (!namea.canBePreprocessorVariableName(cc)) {\n      if (!namea.canBeString(cc)) {\n        throw namea.error(cc, \"Must be string or preprocessorvariable, forex: @:myvar or 'myvar'\");\n      } else {\n        name = namea.asString(cc);\n      }\n    } else {\n      name = namea.asPreprocessorVariableName(cc);\n    }\n\n    if (!name) {\n      throw namea.error(cc, \"This should never happen.\");\n    }\n\n    cc.setParserVariable(name, value);\n  },\n  \"@foreach\": function foreach(cc) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    var pres = ArgParser_1.simpleParse(cc, [\"list\", \"method\"], args);\n    var list = pres.list;\n    var method = pres.method;\n\n    if (!list || !method) {\n      throw this.error(cc, \"@foreach must have a list argument and a method argument.\");\n    }\n\n    if (!list.canBeAbleArray(cc)) {\n      throw list.error(cc, \"List must be a list.\");\n    }\n\n    if (!method.canBeAction(cc)) {\n      throw method.error(cc, 'Method must be action, for example `@{Text \"\\\\(@:repeatitem)\"}`');\n    }\n\n    list.asAbleArray(cc).forEach(function (item) {\n      var newCC = cc.in();\n      newCC.setParserVariable(\"repeatitem\", item);\n      method.asAction(newCC);\n    });\n  },\n  \"@if\": function _if(cc) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    var pres = ArgParser_1.simpleParse(cc, [\"condition\", \"iftrue\", \"iffalse\"], args);\n    var test = pres.condition;\n    var method = pres.iftrue;\n    var elseMethod = pres.iffalse;\n\n    if (!test || !method) {\n      throw this.error(cc, \"@if must have 2-3 arguments. boolean, @{iftrue} @{iffalse}\");\n    }\n\n    if (!test.canBeBoolean(cc)) {\n      throw test.error(cc, \"Test must be a boolean.\");\n    }\n\n    if (!method.canBeAction(cc)) {\n      throw method.error(cc, 'Method must be action, for example `@{Text \"\"}`');\n    }\n\n    if (elseMethod && !elseMethod.canBeAction(cc)) {\n      throw method.error(cc, 'Else method must be action, for example `@{Text \"\"}`');\n    }\n\n    if (test.asBoolean(cc)) {\n      var newCC = cc.in();\n      method.asAction(newCC);\n    } else if (elseMethod) {\n      var _newCC = cc.in();\n\n      elseMethod.asAction(_newCC);\n    }\n  },\n  \"@error\": function error(cc) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n\n    var pres = ArgParser_1.simpleParse(cc, [\"message\"], args);\n    var message = pres.message;\n\n    if (!message) {\n      throw this.error(cc, \"@error must have one argument, the error. Forex: @error 'error message'\");\n    }\n\n    if (!message.canBeString(cc)) {\n      throw message.error(cc, \"Message must be a string\");\n    }\n\n    throw this.error(cc, message.asString(cc));\n  },\n  \"@def\": function def(cc) {\n    for (var _len5 = arguments.length, args_ = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      args_[_key5 - 1] = arguments[_key5];\n    }\n\n    var pres = ArgParser_1.simpleParse(cc, [\"name\", \"arguments\", \"body\"], args_);\n    var name = pres.name;\n    var args = pres.arguments;\n    var cb = pres.body;\n\n    if (!name || !args || !cb) {\n      throw this.error(cc, \"@def must have 3 arguments: name, [args...], @{body}\");\n    }\n\n    if (!name.canBeString(cc)) {\n      throw name.error(cc, \"Name must be a @string\");\n    }\n\n    if (!args.canBeArray(cc)) {\n      throw args.error(cc, \"Args must be an array of [argname]\");\n    }\n\n    if (!cb.canBeAction(cc)) {\n      throw args.error(cc, \"Cb must be an (action) or @{ of actions }\");\n    }\n\n    var nameStr = name.asString(cc).toLowerCase();\n\n    if (!nameStr.startsWith(\"@\")) {\n      nameStr = \"@\".concat(nameStr);\n    }\n\n    var argsArr = args.asArray(cc);\n    cc.setParserAction(nameStr, function (cc) {\n      var newCC = cc.in();\n\n      for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n        args[_key6 - 1] = arguments[_key6];\n      }\n\n      ArgParser_1.ArgParser(argsArr.map(function (aa) {\n        return {\n          name: aa,\n          data: undefined\n        };\n      }), function (name, value) {\n        newCC.setParserVariable(name.name, value);\n      }, function (value) {\n        throw value.error(cc, \"InputArgs are not yet supported here.\");\n      }, function () {\n        return true;\n      }, {\n        args: args,\n        cc: cc\n      });\n      cb.asAction(newCC);\n    });\n  },\n  \"@icon\": glyphAction,\n  \"@glyph\": glyphAction,\n  \"@color\": function color(cc) {\n    for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n      args[_key7 - 1] = arguments[_key7];\n    }\n\n    var pres = ArgParser_1.simpleParse(cc, [\"color\"], args);\n    var colorName = pres.color;\n\n    if (!colorName) {\n      throw this.error(cc, \"Please provide a color name.\");\n    }\n\n    if (!colorName.canBeString(cc)) {\n      throw this.error(cc, \"Color name must be able to be a string\");\n    }\n\n    var color = ShortcutMeta_1.colors[colorName.asString(cc).toLowerCase().replace(/[^a-z]/g, \"\")];\n\n    if (!color) {\n      throw this.error(cc, \"Invalid color name. Must be one of: \".concat(Object.keys(ShortcutMeta_1.colors)));\n    }\n\n    cc.shortcut.color = color;\n  },\n  \"@showinwidget\": function showinwidget(cc) {\n    for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n      args[_key8 - 1] = arguments[_key8];\n    }\n\n    var pres = ArgParser_1.simpleParse(cc, [\"value\"], args);\n    var setTo = pres.value;\n\n    if (!setTo) {\n      throw this.error(cc, \"Please provide a true or false.\");\n    }\n\n    if (!setTo.canBeBoolean(cc)) {\n      throw this.error(cc, \"Value must be able to be a boolean\");\n    }\n\n    cc.shortcut.showInWidget = setTo.asBoolean(cc);\n  },\n  \"@elseif\": function elseif(cc) {\n    var ifAction = cc.peekControlFlow();\n\n    if (!ifAction) {\n      throw this.error(cc, \"The @elseif macro requires an if.\");\n    }\n\n    if (!ifAction[ifAction.length - 1]) {\n      throw this.error(cc, \"The top item of the control flow stack has no items. This should never happen.\");\n    }\n\n    if (ifAction[ifAction.length - 1].wfaction.id !== \"is.workflow.actions.conditional\") {\n      throw this.error(cc, \"ElseIf can only be used on an If action.\"); // todo also error on the if action.\n    } // create otherwise action\n\n\n    var otherwiseAction = HelpfulActions_1.otherwise({\n      start: this.start,\n      end: this.end\n    }, ifAction[ifAction.length - 1].uuid);\n    cc.add(otherwiseAction); // create if action\n\n    var newIfAction = ActionData_1.getActionFromID(\"is.workflow.actions.conditional\");\n\n    if (!newIfAction) {\n      throw this.error(cc, \"The conditional action does not exist. This should never happen.\");\n    }\n\n    for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n      args[_key9 - 1] = arguments[_key9];\n    }\n\n    newIfAction.build.apply(newIfAction, [cc, this, undefined].concat(args));\n    var added = cc.endControlFlow();\n\n    if (!added) {\n      throw this.error(cc, \"Adding an if action did not add any control flow. This should never happen.\");\n    }\n\n    ifAction.push({\n      uuid: added[0].uuid,\n      number: 0,\n      wfaction: added[0].wfaction\n    });\n  }\n};\nexports.default = preprocessorActions;\n/*\n\ncurrent issue:\nif value can be any AsAble, that can't become a class unless you changed all the values everywhere or something\ncanBeX checks if it has a property and the only way to fake that is have variables be proxies but that stops working\nwhen you use .asString on them\n\npossible \"solution\": if(instanceof PreprocessorVariable) {preprocessorvariable.getValue()}\n\n*/","map":null,"metadata":{},"sourceType":"script"}
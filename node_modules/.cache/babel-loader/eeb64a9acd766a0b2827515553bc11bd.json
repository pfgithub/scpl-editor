{"ast":null,"code":"'use strict'; // adapted from http://code.google.com/p/plist/source/browse/trunk/src/main/java/com/dd/plist/BinaryPropertyListWriter.java\n\nvar streamBuffers = require(\"stream-buffers\");\n\nvar debug = false;\n\nfunction Real(value) {\n  this.value = value;\n}\n\nmodule.exports = function (dicts) {\n  var buffer = new streamBuffers.WritableStreamBuffer();\n  buffer.write(new Buffer(\"bplist00\"));\n\n  if (debug) {\n    console.log('create', require('util').inspect(dicts, false, 10));\n  }\n\n  if (dicts instanceof Array && dicts.length === 1) {\n    dicts = dicts[0];\n  }\n\n  var entries = toEntries(dicts);\n\n  if (debug) {\n    console.log('entries', entries);\n  }\n\n  var idSizeInBytes = computeIdSizeInBytes(entries.length);\n  var offsets = [];\n  var offsetSizeInBytes;\n  var offsetTableOffset;\n  updateEntryIds();\n  entries.forEach(function (entry, entryIdx) {\n    offsets[entryIdx] = buffer.size();\n\n    if (!entry) {\n      buffer.write(0x00);\n    } else {\n      write(entry);\n    }\n  });\n  writeOffsetTable();\n  writeTrailer();\n  return buffer.getContents();\n\n  function updateEntryIds() {\n    var strings = {};\n    var entryId = 0;\n    entries.forEach(function (entry) {\n      if (entry.id) {\n        return;\n      }\n\n      if (entry.type === 'string') {\n        if (!entry.bplistOverride && strings.hasOwnProperty(entry.value)) {\n          entry.type = 'stringref';\n          entry.id = strings[entry.value];\n        } else {\n          strings[entry.value] = entry.id = entryId++;\n        }\n      } else {\n        entry.id = entryId++;\n      }\n    });\n    entries = entries.filter(function (entry) {\n      return entry.type !== 'stringref';\n    });\n  }\n\n  function writeTrailer() {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeTrailer');\n    } // 6 null bytes\n\n\n    buffer.write(new Buffer([0, 0, 0, 0, 0, 0])); // size of an offset\n\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeTrailer(offsetSizeInBytes):', offsetSizeInBytes);\n    }\n\n    writeByte(offsetSizeInBytes); // size of a ref\n\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeTrailer(offsetSizeInBytes):', idSizeInBytes);\n    }\n\n    writeByte(idSizeInBytes); // number of objects\n\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeTrailer(number of objects):', entries.length);\n    }\n\n    writeLong(entries.length); // top object\n\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeTrailer(top object)');\n    }\n\n    writeLong(0); // offset table offset\n\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeTrailer(offset table offset):', offsetTableOffset);\n    }\n\n    writeLong(offsetTableOffset);\n  }\n\n  function writeOffsetTable() {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeOffsetTable');\n    }\n\n    offsetTableOffset = buffer.size();\n    offsetSizeInBytes = computeOffsetSizeInBytes(offsetTableOffset);\n    offsets.forEach(function (offset) {\n      writeBytes(offset, offsetSizeInBytes);\n    });\n  }\n\n  function write(entry) {\n    switch (entry.type) {\n      case 'dict':\n        writeDict(entry);\n        break;\n\n      case 'number':\n      case 'double':\n        writeNumber(entry);\n        break;\n\n      case 'UID':\n        writeUID(entry);\n        break;\n\n      case 'array':\n        writeArray(entry);\n        break;\n\n      case 'boolean':\n        writeBoolean(entry);\n        break;\n\n      case 'string':\n      case 'string-utf16':\n        writeString(entry);\n        break;\n\n      case 'date':\n        writeDate(entry);\n        break;\n\n      case 'data':\n        writeData(entry);\n        break;\n\n      default:\n        throw new Error(\"unhandled entry type: \" + entry.type);\n    }\n  }\n\n  function writeDate(entry) {\n    writeByte(0x33);\n    var date = Date.parse(entry.value) / 1000 - 978307200;\n    writeDouble(date);\n  }\n\n  function writeDict(entry) {\n    if (debug) {\n      var keysStr = entry.entryKeys.map(function (k) {\n        return k.id;\n      });\n      var valsStr = entry.entryValues.map(function (k) {\n        return k.id;\n      });\n      console.log('0x' + buffer.size().toString(16), 'writeDict', '(id: ' + entry.id + ')', '(keys: ' + keysStr + ')', '(values: ' + valsStr + ')');\n    }\n\n    writeIntHeader(0xD, entry.entryKeys.length);\n    entry.entryKeys.forEach(function (entry) {\n      writeID(entry.id);\n    });\n    entry.entryValues.forEach(function (entry) {\n      writeID(entry.id);\n    });\n  }\n\n  function writeNumber(entry) {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeNumber', entry.value, ' (type: ' + entry.type + ')', '(id: ' + entry.id + ')');\n    }\n\n    if (entry.type !== 'double' && parseFloat(entry.value.toFixed()) == entry.value) {\n      if (entry.value < 0) {\n        writeByte(0x13);\n        writeBytes(entry.value, 8);\n      } else if (entry.value <= 0xff) {\n        writeByte(0x10);\n        writeBytes(entry.value, 1);\n      } else if (entry.value <= 0xffff) {\n        writeByte(0x11);\n        writeBytes(entry.value, 2);\n      } else if (entry.value <= 0xffffffff) {\n        writeByte(0x12);\n        writeBytes(entry.value, 4);\n      } else {\n        writeByte(0x13);\n        writeBytes(entry.value, 8);\n      }\n    } else {\n      writeByte(0x23);\n      writeDouble(entry.value);\n    }\n  }\n\n  function writeUID(entry) {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeUID', entry.value, ' (type: ' + entry.type + ')', '(id: ' + entry.id + ')');\n    }\n\n    writeIntHeader(0x8, 0x0);\n    writeID(entry.value);\n  }\n\n  function writeArray(entry) {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeArray (length: ' + entry.entries.length + ')', '(id: ' + entry.id + ')');\n    }\n\n    writeIntHeader(0xA, entry.entries.length);\n    entry.entries.forEach(function (e) {\n      writeID(e.id);\n    });\n  }\n\n  function writeBoolean(entry) {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeBoolean', entry.value, '(id: ' + entry.id + ')');\n    }\n\n    writeByte(entry.value ? 0x09 : 0x08);\n  }\n\n  function writeString(entry) {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeString', entry.value, '(id: ' + entry.id + ')');\n    }\n\n    if (entry.type === 'string-utf16' || mustBeUtf16(entry.value)) {\n      var utf16 = new Buffer(entry.value, 'ucs2');\n      writeIntHeader(0x6, utf16.length / 2); // needs to be big endian so swap the bytes\n\n      for (var i = 0; i < utf16.length; i += 2) {\n        var t = utf16[i + 0];\n        utf16[i + 0] = utf16[i + 1];\n        utf16[i + 1] = t;\n      }\n\n      buffer.write(utf16);\n    } else {\n      var utf8 = new Buffer(entry.value, 'ascii');\n      writeIntHeader(0x5, utf8.length);\n      buffer.write(utf8);\n    }\n  }\n\n  function writeData(entry) {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeData', entry.value, '(id: ' + entry.id + ')');\n    }\n\n    writeIntHeader(0x4, entry.value.length);\n    buffer.write(entry.value);\n  }\n\n  function writeLong(l) {\n    writeBytes(l, 8);\n  }\n\n  function writeByte(b) {\n    buffer.write(new Buffer([b]));\n  }\n\n  function writeDouble(v) {\n    var buf = new Buffer(8);\n    buf.writeDoubleBE(v, 0);\n    buffer.write(buf);\n  }\n\n  function writeIntHeader(kind, value) {\n    if (value < 15) {\n      writeByte((kind << 4) + value);\n    } else if (value < 256) {\n      writeByte((kind << 4) + 15);\n      writeByte(0x10);\n      writeBytes(value, 1);\n    } else if (value < 65536) {\n      writeByte((kind << 4) + 15);\n      writeByte(0x11);\n      writeBytes(value, 2);\n    } else {\n      writeByte((kind << 4) + 15);\n      writeByte(0x12);\n      writeBytes(value, 4);\n    }\n  }\n\n  function writeID(id) {\n    writeBytes(id, idSizeInBytes);\n  }\n\n  function writeBytes(value, bytes) {\n    // write low-order bytes big-endian style\n    var buf = new Buffer(bytes);\n    var z = 0; // javascript doesn't handle large numbers\n\n    while (bytes > 4) {\n      buf[z++] = 0;\n      bytes--;\n    }\n\n    for (var i = bytes - 1; i >= 0; i--) {\n      buf[z++] = value >> 8 * i;\n    }\n\n    buffer.write(buf);\n  }\n\n  function mustBeUtf16(string) {\n    return Buffer.byteLength(string, 'utf8') != string.length;\n  }\n};\n\nfunction toEntries(dicts) {\n  if (dicts.bplistOverride) {\n    return [dicts];\n  }\n\n  if (dicts instanceof Array) {\n    return toEntriesArray(dicts);\n  } else if (dicts instanceof Buffer) {\n    return [{\n      type: 'data',\n      value: dicts\n    }];\n  } else if (dicts instanceof Real) {\n    return [{\n      type: 'double',\n      value: dicts.value\n    }];\n  } else if (typeof dicts === 'object') {\n    if (dicts instanceof Date) {\n      return [{\n        type: 'date',\n        value: dicts\n      }];\n    } else if (Object.keys(dicts).length == 1 && typeof dicts.UID === 'number') {\n      return [{\n        type: 'UID',\n        value: dicts.UID\n      }];\n    } else {\n      return toEntriesObject(dicts);\n    }\n  } else if (typeof dicts === 'string') {\n    return [{\n      type: 'string',\n      value: dicts\n    }];\n  } else if (typeof dicts === 'number') {\n    return [{\n      type: 'number',\n      value: dicts\n    }];\n  } else if (typeof dicts === 'boolean') {\n    return [{\n      type: 'boolean',\n      value: dicts\n    }];\n  } else {\n    throw new Error('unhandled entry: ' + dicts);\n  }\n}\n\nfunction toEntriesArray(arr) {\n  if (debug) {\n    console.log('toEntriesArray');\n  }\n\n  var results = [{\n    type: 'array',\n    entries: []\n  }];\n  arr.forEach(function (v) {\n    var entry = toEntries(v);\n    results[0].entries.push(entry[0]);\n    results = results.concat(entry);\n  });\n  return results;\n}\n\nfunction toEntriesObject(dict) {\n  if (debug) {\n    console.log('toEntriesObject');\n  }\n\n  var results = [{\n    type: 'dict',\n    entryKeys: [],\n    entryValues: []\n  }];\n  Object.keys(dict).forEach(function (key) {\n    var entryKey = toEntries(key);\n    results[0].entryKeys.push(entryKey[0]);\n    results = results.concat(entryKey[0]);\n  });\n  Object.keys(dict).forEach(function (key) {\n    var entryValue = toEntries(dict[key]);\n    results[0].entryValues.push(entryValue[0]);\n    results = results.concat(entryValue);\n  });\n  return results;\n}\n\nfunction computeOffsetSizeInBytes(maxOffset) {\n  if (maxOffset < 256) {\n    return 1;\n  }\n\n  if (maxOffset < 65536) {\n    return 2;\n  }\n\n  if (maxOffset < 4294967296) {\n    return 4;\n  }\n\n  return 8;\n}\n\nfunction computeIdSizeInBytes(numberOfIds) {\n  if (numberOfIds < 256) {\n    return 1;\n  }\n\n  if (numberOfIds < 65536) {\n    return 2;\n  }\n\n  return 4;\n}\n\nmodule.exports.Real = Real;","map":null,"metadata":{},"sourceType":"script"}
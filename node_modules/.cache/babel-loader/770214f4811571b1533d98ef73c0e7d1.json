{"ast":null,"code":"\"use strict\";\n\nvar _possibleConstructorReturn = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _classCallCheck = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/brandonjordan/Documents/GitHub/scpl-editor/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar totalSteps = 0;\nvar began;\n\nvar Performance =\n/*#__PURE__*/\nfunction () {\n  function Performance() {\n    _classCallCheck(this, Performance);\n  }\n\n  _createClass(Performance, null, [{\n    key: \"startMonitoring\",\n    value: function startMonitoring() {\n      totalSteps = 0;\n      began = new Date();\n      console.log(\"Started parsing.\"); //eslint-disable-line no-console\n    }\n  }, {\n    key: \"stopMonitoring\",\n    value: function stopMonitoring() {\n      var ended = new Date(); //eslint-disable-next-line no-console\n\n      console.log(\"Parsed in \".concat(totalSteps, \" steps over \").concat(ended.getTime() - began.getTime(), \"ms.\"));\n    }\n  }]);\n\n  return Performance;\n}();\n\nexports.Performance = Performance;\n\nfunction calculateChange(str, position) {\n  var change = str;\n\n  if (str.indexOf(\"\\n\") > -1) {\n    var split = str.split(\"\\n\");\n    position[0] += split.length - 1;\n    position[1] = 0;\n  }\n\n  position[1] += change.length;\n}\n\nvar Production =\n/*#__PURE__*/\nfunction () {\n  function Production() {\n    var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (a) {\n      return a;\n    };\n\n    _classCallCheck(this, Production);\n\n    this.cb = cb;\n  }\n\n  _createClass(Production, [{\n    key: \"scb\",\n    value: function scb(cb) {\n      this.cb = cb;\n      return this;\n    }\n  }, {\n    key: \"getProd\",\n    value: function getProd() {\n      return this;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(_string, _position) {\n      totalSteps++;\n      return {\n        success: false\n      };\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"UndefinedProduction\";\n    }\n  }, {\n    key: \"nameOrTostring\",\n    value: function nameOrTostring() {\n      return this.name || this.toString();\n    }\n  }]);\n\n  return Production;\n}();\n\nexports.Production = Production;\n\nvar OrderedProduction =\n/*#__PURE__*/\nfunction (_Production) {\n  _inherits(OrderedProduction, _Production);\n\n  function OrderedProduction() {\n    var _this;\n\n    _classCallCheck(this, OrderedProduction);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(OrderedProduction).call(this));\n\n    for (var _len = arguments.length, requirements = new Array(_len), _key = 0; _key < _len; _key++) {\n      requirements[_key] = arguments[_key];\n    }\n\n    _this.requirements = requirements;\n    return _this;\n  }\n\n  _createClass(OrderedProduction, [{\n    key: \"parse\",\n    value: function parse(string, position) {\n      _get(_getPrototypeOf(OrderedProduction.prototype), \"parse\", this).call(this, string, position);\n\n      var resdata = [];\n      var startpos = position.slice();\n      var success = this.requirements.every(function (requirement) {\n        var result = requirement.getProd().parse(string, position.slice());\n\n        if (!result.success) {\n          return false;\n        }\n\n        string = result.remainingStr;\n        position = result.pos;\n        resdata.push(result.data);\n        return true;\n      });\n\n      if (!success) {\n        return {\n          success: false\n        };\n      }\n\n      return {\n        data: this.cb(resdata, startpos, position),\n        remainingStr: string,\n        success: true,\n        pos: position\n      };\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.requirements.map(function (option) {\n        return option.getProd().nameOrTostring();\n      }).join(\" \"));\n    }\n  }]);\n\n  return OrderedProduction;\n}(Production);\n\nexports.OrderedProduction = OrderedProduction;\n\nvar OrProduction =\n/*#__PURE__*/\nfunction (_Production2) {\n  _inherits(OrProduction, _Production2);\n\n  function OrProduction() {\n    var _this2;\n\n    _classCallCheck(this, OrProduction);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(OrProduction).call(this));\n\n    for (var _len2 = arguments.length, options = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      options[_key2] = arguments[_key2];\n    }\n\n    _this2.options = options;\n    return _this2;\n  }\n\n  _createClass(OrProduction, [{\n    key: \"parse\",\n    value: function parse(string, position) {\n      _get(_getPrototypeOf(OrProduction.prototype), \"parse\", this).call(this, string, position);\n\n      var resdata;\n      var startpos = position.slice();\n      var success = this.options.some(function (option) {\n        // find the first option that parses... might cause problems if things try to parse too deep only to realise the code is wrong... may want to have some number of depth or something idk\n        var result = option.getProd().parse(string, position.slice());\n\n        if (!result.success) {\n          return false;\n        }\n\n        string = result.remainingStr;\n        position = result.pos;\n        resdata = result.data;\n        return true;\n      });\n\n      if (!success) {\n        return {\n          success: false\n        };\n      }\n\n      return {\n        data: this.cb(resdata, startpos, position),\n        remainingStr: string,\n        success: true,\n        pos: position\n      };\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"( \".concat(this.options.map(function (option) {\n        return option.getProd().nameOrTostring();\n      }).join(\" | \"), \" )\");\n    }\n  }]);\n\n  return OrProduction;\n}(Production);\n\nexports.OrProduction = OrProduction; // remove notproduction for now\n\nvar RegexProduction =\n/*#__PURE__*/\nfunction (_Production3) {\n  _inherits(RegexProduction, _Production3);\n\n  function RegexProduction(regex) {\n    var _this3;\n\n    _classCallCheck(this, RegexProduction);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(RegexProduction).call(this));\n    _this3.regex = regex;\n    return _this3;\n  }\n\n  _createClass(RegexProduction, [{\n    key: \"parse\",\n    value: function parse(string, position) {\n      _get(_getPrototypeOf(RegexProduction.prototype), \"parse\", this).call(this, string, position);\n\n      var match = string.match(this.regex);\n      var startpos = position.slice();\n\n      if (match && string.startsWith(match[0])) {\n        string = string.replace(match[0], \"\"); // replace does the first instance on a string. PERFORMANCE: substr could probably be used instead.\n\n        calculateChange(match[0], position);\n        return {\n          data: this.cb(match, startpos, position),\n          remainingStr: string,\n          success: true,\n          pos: position\n        };\n      }\n\n      if (match) {\n        //eslint-disable-next-line no-console\n        console.warn(\"WARN: regex \", this.regex, \" does not start matching at beginning of line\");\n      }\n\n      return {\n        success: false\n      };\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.regex.toString());\n    }\n  }]);\n\n  return RegexProduction;\n}(Production);\n\nexports.RegexProduction = RegexProduction;\n\nvar StringProduction =\n/*#__PURE__*/\nfunction (_Production4) {\n  _inherits(StringProduction, _Production4);\n\n  function StringProduction(string) {\n    var _this4;\n\n    _classCallCheck(this, StringProduction);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(StringProduction).call(this));\n    _this4.string = string;\n    return _this4;\n  }\n\n  _createClass(StringProduction, [{\n    key: \"parse\",\n    value: function parse(string, position) {\n      _get(_getPrototypeOf(StringProduction.prototype), \"parse\", this).call(this, string, position);\n\n      var startpos = position.slice();\n\n      if (string.startsWith(this.string)) {\n        string = string.replace(this.string, \"\"); // replace does the first instance on a string\n\n        calculateChange(this.string, position);\n        return {\n          data: this.cb(this.string, startpos, position),\n          remainingStr: string,\n          success: true,\n          pos: position\n        };\n      }\n\n      return {\n        success: false\n      };\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(JSON.stringify(this.string));\n    }\n  }]);\n\n  return StringProduction;\n}(Production);\n\nexports.StringProduction = StringProduction;\n\nvar ManyProduction =\n/*#__PURE__*/\nfunction (_Production5) {\n  _inherits(ManyProduction, _Production5);\n\n  function ManyProduction(thing) {\n    var _this5;\n\n    var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n\n    _classCallCheck(this, ManyProduction);\n\n    // range = 0.. 1.. 0..1 ..1 or something\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(ManyProduction).call(this));\n    _this5.prod = thing;\n    _this5.start = start;\n    _this5.end = end;\n    return _this5;\n  }\n\n  _createClass(ManyProduction, [{\n    key: \"parse\",\n    value: function parse(string, position) {\n      _get(_getPrototypeOf(ManyProduction.prototype), \"parse\", this).call(this, string, position);\n\n      var results = [];\n      var succeeding = true;\n      var startpos = position.slice();\n\n      while (succeeding) {\n        if (results.length > this.end) {\n          succeeding = false;\n          continue;\n        }\n\n        var result = this.prod.getProd().parse(string, position.slice());\n\n        if (!result.success) {\n          succeeding = false;\n          continue;\n        }\n\n        var changed = string.length - result.remainingStr.length;\n\n        if (changed === 0) {\n          succeeding = false;\n          continue;\n        } // if it succeeds but matches nothing, count it as a failure (to avoid loops)\n\n\n        position = result.pos;\n        string = result.remainingStr;\n        results.push(result.data);\n      }\n\n      if (results.length < this.start) {\n        return {\n          success: false\n        };\n      }\n\n      return {\n        data: this.cb(results, startpos, position),\n        remainingStr: string,\n        success: true,\n        pos: position\n      };\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"{ \".concat(this.start, \"..\").concat(this.end, \" }( \").concat(this.prod.getProd().nameOrTostring(), \" )\");\n    }\n  }]);\n\n  return ManyProduction;\n}(Production);\n\nexports.ManyProduction = ManyProduction;","map":null,"metadata":{},"sourceType":"script"}